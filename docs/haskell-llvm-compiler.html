<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>Things that amuse me</title>

  <script type="text/javascript">(function() { var a=window;function c(b){this.t={};this.tick=function(b,i,d){d=d!=void 0?d:(new Date).getTime();this.t[b]=[d,i]};this.tick("start",null,b)}var e=new c;a.jstiming={Timer:c,load:e};try{var g=null;a.chrome&&a.chrome.csi&&(g=Math.floor(a.chrome.csi().pageT));g==null&&a.gtbExternal&&(g=a.gtbExternal.pageT());g==null&&a.external&&(g=a.external.pageT);g&&(a.jstiming.pt=g)}catch(h){};a.tickAboveFold=function(b){var f=0;if(b.offsetParent){do f+=b.offsetTop;while(b=b.offsetParent)}b=f;b<=750&&a.jstiming.load.tick("aft")};var j=!1;function k(){j||(j=!0,a.jstiming.load.tick("firstScrollTime"))}a.addEventListener?a.addEventListener("scroll",k,!1):a.attachEvent("onscroll",k);
 })();</script><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="MSSmartTagsPreventParsing" content="true" />
<meta name="generator" content="Blogger" />
<link rel="icon" type="image/vnd.microsoft.icon" href="http://www.blogger.com/favicon.ico"/>
<link rel="alternate" type="application/atom+xml" title="Things that amuse me - Atom" href="http://augustss.blogspot.com/feeds/posts/default" />
<link rel="alternate" type="application/rss+xml" title="Things that amuse me - RSS" href="http://augustss.blogspot.com/feeds/posts/default?alt=rss" />
<link rel="service.post" type="application/atom+xml" title="Things that amuse me - Atom" href="http://www.blogger.com/feeds/25541020/posts/default" />
<link rel="EditURI" type="application/rsd+xml" title="RSD" href="http://www.blogger.com/rsd.g?blogID=25541020" />
<link rel="alternate" type="application/atom+xml" title="Things that amuse me - Atom" href="http://augustss.blogspot.com/feeds/4910575514980456234/comments/default" />
 <link rel="stylesheet" type="text/css" href="http://www.blogger.com/static/v1/v-css/50269083-blog_controls.css"/> <link rel="stylesheet" type="text/css" href="http://www.blogger.com/dyn-css/authorization.css?targetBlogID=25541020&zx=f7347cf5-ee1a-4763-9dd1-c8c83d4f306e"/>

  <style type="text/css">
/*
-----------------------------------------------
Blogger Template Style
Name:     Minima
Designer: Douglas Bowman
URL:      www.stopdesign.com
Date:     26 Feb 2004
----------------------------------------------- */


body {
  background:#fff;
  margin:0;
  padding:40px 20px;
  font:x-small Georgia,Serif;
  text-align:center;
  color:#333;
  font-size/* */:/**/small;
  font-size: /**/small;
  }
a:link {
  color:#58a;
  text-decoration:none;
  }
a:visited {
  color:#969;
  text-decoration:none;
  }
a:hover {
  color:#c60;
  text-decoration:underline;
  }
a img {
  border-width:0;
  }


/* Header
----------------------------------------------- */
@media all {
  #header {
    width:660px;
    margin:0 auto 10px;
    border:1px solid #ccc;
    }
  }
@media handheld {
  #header {
    width:90%;
    }
  }
#blog-title {
  margin:5px 5px 0;
  padding:20px 20px .25em;
  border:1px solid #eee;
  border-width:1px 1px 0;
  font-size:200%;
  line-height:1.2em;
  font-weight:normal;
  color:#666;
  text-transform:uppercase;
  letter-spacing:.2em;
  }
#blog-title a {
  color:#666;
  text-decoration:none;
  }
#blog-title a:hover {
  color:#c60;
  }
#description {
  margin:0 5px 5px;
  padding:0 20px 20px;
  border:1px solid #eee;
  border-width:0 1px 1px;
  max-width:700px;
  font:78%/1.4em "Trebuchet MS",Trebuchet,Arial,Verdana,Sans-serif;
  text-transform:uppercase;
  letter-spacing:.2em;
  color:#999;
  }


/* Content
----------------------------------------------- */
@media all {
  #content {
    width:660px;
    margin:0 auto;
    padding:0;
    text-align:left;
    }
  #main {
    width:410px;
    float:left;
    }
  #sidebar {
    width:220px;
    float:right;
    }
  }
@media handheld {
  #content {
    width:90%;
    }
  #main {
    width:100%;
    float:none;
    }
  #sidebar {
    width:100%;
    float:none;
    }
  }

/* Headings
----------------------------------------------- */
h2 {
  margin:1.5em 0 .75em;
  font:78%/1.4em "Trebuchet MS",Trebuchet,Arial,Verdana,Sans-serif;
  text-transform:uppercase;
  letter-spacing:.2em;
  color:#999;
  }


/* Posts
----------------------------------------------- */
@media all {
  .date-header {
    margin:1.5em 0 .5em;
    }
  .post {
    margin:.5em 0 1.5em;
    border-bottom:1px dotted #ccc;
    padding-bottom:1.5em;
    }
  }
@media handheld {
  .date-header {
    padding:0 1.5em 0 1.5em;
    }
  .post {
    padding:0 1.5em 0 1.5em;
    }
  }
.post-title {
  margin:.25em 0 0;
  padding:0 0 4px;
  font-size:140%;
  font-weight:normal;
  line-height:1.4em;
  color:#c60;
  }
.post-title a, .post-title a:visited, .post-title strong {
  display:block;
  text-decoration:none;
  color:#c60;
  font-weight:normal;
  }
.post-title strong, .post-title a:hover {
  color:#333;
  }
.post div {
  margin:0 0 .75em;
  line-height:1.6em;
  }
p.post-footer {
  margin:-.25em 0 0;
  color:#ccc;
  }
.post-footer em, .comment-link {
  font:78%/1.4em "Trebuchet MS",Trebuchet,Arial,Verdana,Sans-serif;
  text-transform:uppercase;
  letter-spacing:.1em;
  }
.post-footer em {
  font-style:normal;
  color:#999;
  margin-right:.6em;
  }
.comment-link {
  margin-left:.6em;
  }
.post img {
  padding:4px;
  border:1px solid #ddd;
  }
.post blockquote {
  margin:1em 20px;
  }
.post blockquote p {
  margin:.75em 0;
  }


/* Comments
----------------------------------------------- */
#comments h4 {
  margin:1em 0;
  font:bold 78%/1.6em "Trebuchet MS",Trebuchet,Arial,Verdana,Sans-serif;
  text-transform:uppercase;
  letter-spacing:.2em;
  color:#999;
  }
#comments h4 strong {
  font-size:130%;
  }
#comments-block {
  margin:1em 0 1.5em;
  line-height:1.6em;
  }
#comments-block dt {
  margin:.5em 0;
  }
#comments-block dd {
  margin:.25em 0 0;
  }
#comments-block dd.comment-timestamp {
  margin:-.25em 0 2em;
  font:78%/1.4em "Trebuchet MS",Trebuchet,Arial,Verdana,Sans-serif;
  text-transform:uppercase;
  letter-spacing:.1em;
  }
#comments-block dd p {
  margin:0 0 .75em;
  }
.deleted-comment {
  font-style:italic;
  color:gray;
  }


/* Sidebar Content
----------------------------------------------- */
#sidebar ul {
  margin:0 0 1.5em;
  padding:0 0 1.5em;
  border-bottom:1px dotted #ccc;
  list-style:none;
  }
#sidebar li {
  margin:0;
  padding:0 0 .25em 15px;
  text-indent:-15px;
  line-height:1.5em;
  }
#sidebar p {
  color:#666;
  line-height:1.5em;
  }


/* Profile
----------------------------------------------- */
#profile-container {
  margin:0 0 1.5em;
  border-bottom:1px dotted #ccc;
  padding-bottom:1.5em;
  }
.profile-datablock {
  margin:.5em 0 .5em;
  }
.profile-img {
  display:inline;
  }
.profile-img img {
  float:left;
  padding:4px;
  border:1px solid #ddd;
  margin:0 8px 3px 0;
  }
.profile-data {
  margin:0;
  font:bold 78%/1.6em "Trebuchet MS",Trebuchet,Arial,Verdana,Sans-serif;
  text-transform:uppercase;
  letter-spacing:.1em;
  }
.profile-data strong {
  display:none;
  }
.profile-textblock {
  margin:0 0 .5em;
  }
.profile-link {
  margin:0;
  font:78%/1.4em "Trebuchet MS",Trebuchet,Arial,Verdana,Sans-serif;
  text-transform:uppercase;
  letter-spacing:.1em;
  }


/* Footer
----------------------------------------------- */
#footer {
  width:660px;
  clear:both;
  margin:0 auto;
  }
#footer hr {
  display:none;
  }
#footer p {
  margin:0;
  padding-top:15px;
  font:78%/1.6em "Trebuchet MS",Trebuchet,Verdana,Sans-serif;
  text-transform:uppercase;
  letter-spacing:.1em;
  }
  </style>

<!-- --><style type="text/css">@import url(http://www.blogger.com/static/v1/v-css/navbar/697174003-classic.css);
div.b-mobile {display:none;}
</style>

</head>

<body><script type="text/javascript">
    function setAttributeOnload(object, attribute, val) {
      if(window.addEventListener) {
        window.addEventListener("load",
          function(){ object[attribute] = val; }, false);
      } else {
        window.attachEvent('onload', function(){ object[attribute] = val; });
      }
    }
    function showRelatedContent(args) {
      var el = document.getElementById('related-iframe');
      if (el.parentNode.style.display != 'none') {
        el.parentNode.style.display = 'none';
        document.onclick = showRelatedContent.prevOnClick;
        return;
      }
      
      var match = /(?:^[?]|&)c=([0-9]+)(?:&|(?!.))/.exec(args);
      if (match !== null) {
        document.getElementById('related-loading').style.left = match[1] + 'px';
        el.style.left = Math.max(0, match[1] - parseInt(el.width) / 2) + 'px';
      }
      el.src = "http://www.blogger.com"
          + '/related-content.g?q='
          + window.location.href
          + '&id=' + "25541020";
      el.parentNode.style.display = 'block';
      showRelatedContent.prevOnClick = document.onclick;

      // Hide related-content dropdown when clicking anywhere but on it.
      document.onclick = function() {
        var el = document.getElementById('related-iframe');
        if (el.parentNode.style.display != 'none') {
          el.parentNode.style.display = 'none';
        }
        document.onclick = showRelatedContent.prevOnClick;
      };
    }
  </script>
<iframe src="http://www.blogger.com/navbar.g?targetBlogID=25541020&amp;blogName=Things+that+amuse+me&amp;publishMode=PUBLISH_MODE_BLOGSPOT&amp;navbarType=BLUE&amp;layoutType=CLASSIC&amp;searchRoot=http%3A%2F%2Faugustss.blogspot.com%2Fsearch&amp;blogLocale=en_US&amp;homepageUrl=http%3A%2F%2Faugustss.blogspot.com%2F" marginwidth="0" marginheight="0" scrolling="no" frameborder="0" height="30px" width="100%" id="navbar-iframe" allowtransparency="true" title="Blogger Navigation and Search"></iframe>

<div></div>

<div id="header">

  <h1 id="blog-title">
    <a href="http://augustss.blogspot.com/">
	Things that amuse me
	</a>
  </h1>
  <p id="description"></p>

</div>

<!-- Begin #content -->
<div id="content">


<!-- Begin #main -->
<div id="main"><div id="main2">



    
  <h2 class="date-header">Wednesday, June 10, 2009</h2>
  

  
     
  <!-- Begin .post -->
  <div class="post"><a name="4910575514980456234"></a>
         

	         <div class="post-body">
	<div>
      <div style="clear:both;"></div><h2>More LLVM</h2>

Recently someone asked me on #haskell if you could use the Haskell LLVM bindings to compile some abstract syntax to a Haskell function.  Naturally I said yes, but then I realized I had only done it for a boring language with just one type.  I had no doubt that it could be done for more complicated languages with multiple types, but it might not be totally obvious how.  So I decided to write a simple compiler, and this blog post is the result.

First, a simple example:
<pre>
    main = do
        let f :: Double -> Double
            Just f = compile "\\ (x::Double) -> if x == 0 then 0 else 1/(x*x)"
        print (f 2, f 3, f 0)
</pre>
Running this program produces (as expected)
<pre>
    (0.25,0.1111111111111111,0.0)
</pre>
What has happened is that the string has been parsed to an abstract syntax tree, translated into LLVM code, then to machine code, and finally turned back into a Haskell callable function.  Many things can go wrong along the way, like syntax and type errors, so <tt>compile</tt> returns a <tt>Maybe</tt> type to indicate if things went right or wrong.  (A more serious version of the <tt>compile</tt> function would return an error message when something has gone wrong.)

The definition of the compilation function is simple and illustrates the flow of the compiler
<pre>
compile :: (Translate a) => String -> Maybe a
compile = fmap translate . toTFun &lt;=&lt; mParseUFun
</pre>
The context <tt>Translate</tt> is there to limit the types that can actually be translated; it's a necessary evil and exactly what types are allowed depends on how advanced we make the compiler.  Had we ignored the <tt>Maybe</tt> type the definitions would have been
<pre>
compile = translate . toTFun . mParseUFun
</pre>
which says, first parse to the type <tt>UFun</tt> (untyped expressions), then type check and turn it into the type <tt>TFun a</tt>, and finally translate <tt>TFun a</tt> into an <tt>a</tt> by LLVM compilation.

Let's see how this all works.

<h3>The UExp module</h3>
The first step is to just define an abstract syntax for the expressions that we want to handle.  I'm only allowing leading lambdas (this a very first order language), so there's a distiction between the top level <tt>UFun</tt> type and the expression type <tt>UExp</tt>.  The U prefix indicates that this version of the syntax is not yet type checked.

The definition is pretty boring, but here it is:
<pre>
{-# OPTIONS_GHC -fno-warn-unused-binds #-}
{-# LANGUAGE RecordWildCards #-}
module UExp(Id, UFun(..), UTyp(..), UExp(..), parseUFun, showOp, mParseUFun) where
import Data.Maybe
import Data.List
import Data.Function
import Text.ParserCombinators.Parsec
import Text.ParserCombinators.Parsec.Expr
import Text.ParserCombinators.Parsec.Token
import Text.ParserCombinators.Parsec.Language

type Id = String

data UFun = UFun [(Id, UTyp)] UExp

data UTyp = UTBol | UTDbl

data UExp
    = UDbl Double        -- ^ Double literal
    | UBol Bool          -- ^ Bool literal
    | UVar Id            -- ^ Variable
    | UApp Id [UExp]     -- ^ Function application
    | ULet Id UExp UExp  -- ^ Local binding
</pre>

Naturally, we want to be able to show the expressions, if nothing else so for debugging.  So I make a <tt>Show</tt> instance that shows them in a nice way respecting operator precedences etc.  There's nothing exciting going on, the large number of lines is just to cover operator printing.
<pre>
instance Show UFun where
    showsPrec p (UFun [] e) = showsPrec p e
    showsPrec p (UFun vts e) = showParen (p>0) (showString "\\ " . foldr (.) (showString "-> ") (map f vts) . showsPrec 0 e)
      where f (v, t) = showParen True (showString v . showString " :: " . showsPrec 0 t) . showString " "

instance Show UTyp where
    showsPrec _ UTDbl = showString "Double"
    showsPrec _ UTBol = showString "Bool"

instance Show UExp where
    showsPrec p (UDbl d) = showsPrec p d
    showsPrec p (UBol b) = showsPrec p b
    showsPrec _ (UVar i) = showString i
    showsPrec p (UApp "if" [c, t, e]) =
      showParen (p>0) (showString "if " . showsPrec 0 c . showString " then " . showsPrec 0 t . showString " else " . showsPrec 0 e)
    showsPrec p (UApp op [a, b]) = showOp p op a b
    showsPrec _ (UApp op _) = error $ "Uxp.show " ++ op
    showsPrec p (ULet i e b) =
      showParen (p>0) (showString "let " . showString i . showString " = " . showsPrec 0 e . showString " in " . showsPrec 0 b)

showOp :: (Show a, Show b) => Int -> String -> a -> b -> String -> String
showOp q sop a b = showParen (q>mp) (showsPrec lp a . showString sop . showsPrec rp b)
  where (lp,mp,rp) = case lookup sop ops of
                    Just (p, AssocLeft)  -> (p,   p, p+1)
                    Just (p, AssocRight) -> (p+1, p, p)
                    Just (p, AssocNone)  -> (p+1, p, p+1)
                    Nothing              -> (9,   9, 10)

ops :: [(String, (Int, Assoc))]
ops = [("+",  (6, AssocLeft)),
       ("-",  (6, AssocLeft)),
       ("*",  (7, AssocLeft)),
       ("/",  (7, AssocLeft)),
       ("==", (4, AssocNone)),
       ("&lt;=", (4, AssocNone)),
       ("&&", (3, AssocRight)),
       ("||", (2, AssocRight))
      ]
</pre>

We also want to be able to parse, so I'm using <tt>Parsec</tt> to parse the string and produce an AST.  Again, there's nothing interesting going on.  I use the Haskell lexical analysis provided by <tt>Parsec</tt>.  This is available as a <tt>TokenParser</tt> record, which can be conveniently opened with the <tt>RecordWildcard</tt> notation <tt>TokenParser{..}</tt>.
<pre>
parseUFun :: SourceName -> String -> Either ParseError UFun
parseUFun = parse $ do f &lt;- pFun; eof; return f
  where TokenParser{..} = haskell
        pFun = do
            vts &lt;- between (reservedOp "\\")
                           (reservedOp "->")
                           (many $ parens $ do v &lt;- identifier; reservedOp "::"; t &lt;- pTyp; return (v, t))
               &lt;|> return []
            e &lt;- pExp
            return $ UFun vts e
        pTyp = choice [do reserved "Bool"; return UTBol, do reserved "Double"; return UTDbl]
        pExp = choice [pIf, pLet, pOExp]
        pIf = do reserved "if"; c &lt;- pExp; reserved "then"; t &lt;- pExp; reserved "else"; e &lt;- pExp; return $ UApp "if" [c, t, e]
        pLet = do reserved "let"; i &lt;- identifier; reservedOp "="; e &lt;- pExp; reserved "in"; b &lt;- pExp; return $ ULet i e b
        pOExp = buildExpressionParser opTable pAExp
        pAExp = choice [pDbl, pVar, parens pExp]
        pVar = fmap eVar identifier
        pDbl = fmap (either (UDbl . fromInteger) UDbl) naturalOrFloat
        eVar i = if i == "False" then UBol False else if i == "True" then UBol True else UVar i

        opTable = reverse . map (map mkOp) . groupBy ((==) `on` prec) . sortBy (compare `on` prec) $ ops
          where mkOp (s, (_, a)) = Infix (do reservedOp s; return $ \ x y -> UApp s [x, y]) a
                prec = fst . snd

mParseUFun :: String -> Maybe UFun
mParseUFun = either (const Nothing) Just . (parseUFun "")
</pre>

The parser is packaged up in <tt>mParseUFun</tt> which returns an AST if it all worked.


<h3>The TExp module</h3>
Since the LLVM API is typed it's much easier to translate a typed abstract syntax tree than an untyped abstract syntax tree.  The <tt>TExp</tt> module contains the definition of the typed AST and the type checker that converts to it.

There are many ways to formulate type safe abstract syntax trees.  I've chosen to use GADTs.  I've also picked to represent variables (still) by identifiers, which means that the syntax tree is not necessarily type safe.  Furthermore, I've chosen a very limited way to represent function application since this is all I need for this example.  The variantions on this are endless.

<pre>
{-# LANGUAGE GADTs, ExistentialQuantification, PatternGuards #-}
module TExp(Id,
            TFun(..), TTyp(..), TExp(..), DblOp(..), BolOp(..), CmpOp(..),
            Equal(..), test,
            Type(..),
            AFun(..), extractFun,
            typeCheck, toTFun) where
import Data.Maybe
import Control.Monad
import UExp

data TFun a where
    TBody :: TExp a                 -> TFun a
    TLam  :: Id -> TTyp a -> TFun b -> TFun (a->b)

data TTyp a where
    TTBol ::                     TTyp Bool
    TTDbl ::                     TTyp Double
    TTArr :: TTyp a -> TTyp b -> TTyp (a->b)

data TExp a where
    TDbl   :: Double                                            -> TExp Double
    TBol   :: Bool                                              -> TExp Bool
    TDblOp :: DblOp     -> TExp Double -> TExp Double           -> TExp Double
    TBolOp :: BolOp     -> TExp Bool   -> TExp Bool             -> TExp Bool
    TCmpOp :: CmpOp     -> TExp Double -> TExp Double           -> TExp Bool
    TIf    :: TExp Bool -> TExp a      -> TExp a                -> TExp a
    TLet   :: Id        -> TTyp a      -> TExp a      -> TExp b -> TExp b
    TVar   :: Id                                                -> TExp a

data DblOp = DAdd | DSub | DMul | DDiv
    deriving (Eq, Show)

data BolOp = BAnd | BOr
    deriving (Eq, Show)

data CmpOp = CEq | CLe
    deriving (Eq, Show)
</pre>
So for instance, <tt>UApp "+" [UVar "x", UDbl 2.2]</tt> will be represented by <tt>TDblOp DAdd (TVar "x") (TDbl 2.2)</tt> which has type <tt>TExp Double</tt>.  So the type of the expression is now accurately reflected in the type of the syntax tree.  Even the <tt>UTyp</tt> type now has a typed equivalent where the real type is reflected.

For completeness, here's some code for pretty printing etc.
<pre>
{-# LANGUAGE GADTs, ExistentialQuantification, PatternGuards #-}
module TExp(Id,
            TFun(..), TTyp(..), TExp(..), DblOp(..), BolOp(..), CmpOp(..),
            Equal(..), test,
            Type(..),
            AFun(..), extractFun,
            typeCheck, toTFun) where
import Data.Maybe
import Control.Monad
import UExp

instance Show (TFun a) where
    showsPrec p (TBody e) = showsPrec p e
    showsPrec p (TLam i t e) = showParen (p>0)
      (showString "\\ " . showParen True (showString i . showString " :: " . showsPrec 0 t) . showString " -> " . showsPrec 0 e)

instance Show (TTyp a) where
    showsPrec _ TTBol = showString "Bool"
    showsPrec _ TTDbl = showString "Double"
    showsPrec p (TTArr a b) = showParen (p>5) (showsPrec 6 a . showString " -> " . showsPrec 5 b)

instance Show (TExp a) where
    showsPrec p (TDbl d) = showsPrec p d
    showsPrec p (TBol b) = showsPrec p b
    showsPrec _ (TVar i) = showString i
    showsPrec p (TDblOp op a b) = showOp p (fromJust $ lookup op [(DMul, "*"), (DAdd, "+"), (DSub, "-"), (DDiv, "/")]) a b
    showsPrec p (TBolOp op a b) = showOp p (fromJust $ lookup op [(BAnd, "&&"), (BOr, "||")]) a b
    showsPrec p (TCmpOp op a b) = showOp p (fromJust $ lookup op [(CEq, "=="), (CLe, "&lt;=")]) a b
    showsPrec p (TIf c t e) = showParen (p>0) (showString "if " . showsPrec 0 c . showString " then " . showsPrec 0 t . showString " else " . showsPrec 0 e)
    showsPrec p (TLet i _ e b) =
      showParen (p>0) (showString "let " . showString i . showString " = " . showsPrec 0 e . showString " in " . showsPrec 0 b)

</pre>

The aim of the type checker is to transform from the <tt>UExp</tt> type to the <tt>TExp</tt> type, so basically
<pre>
typeCheckExp :: UExp -> TExp a
</pre>
But things can go wrong, so it's impossible to always return a <tt>TExp</tt>, so let's use a <tt>Maybe</tt> type:
<pre>
typeCheckExp :: UExp -> Maybe (TExp a)
</pre>
But wait!  This type is totally wrong.  Why?  Because it promises that given a <tt>UExp</tt> the type checker can return <b>any</b> type, i.e., writing out the (normally implicit) quantifier the type is:
<pre>
typeCheckExp :: forall a . UExp -> Maybe (TExp a)
</pre>
But this is not the case, the type checker will figure out a type and return an expression with this specific type, so the type we really want is
<pre>
typeCheckExp :: exists a . UExp -> Maybe (TExp a)
</pre>
Haskell doesn't allow this type to be written this way; we need to package up the existential type in a data type.  Like so:
<pre>
data ATExp = forall a . TExp a ::: TTyp a

data AFun = forall a . AFun (TFun a) (TTyp a)
</pre>
It might look funny that the existential type is written with a forall, but it makes sense when looking at the type of the constructor function (but not when doing pattern matching).

Now we can attempt a couple of cases of the type checker:
<pre>
typeCheckExp :: UExp -> Maybe ATExp
typeCheckExp (UDbl d) =
    return $ TDbl d ::: TTDbl
typeCheckExp (UBol b) =
    return $ TBol b ::: TTBol
</pre>
They look quite nice, and they actually work.  So what about something more complicated, like arithmetic?
<pre>
typeCheckExp (UApp op [a, b]) | Just dop <- lookup op [("+", DAdd), ("-", DSub), ("*", DMul), ("/", DDiv)] = do
    a' ::: TTDbl &lt;- typeCheckExp a
    b' ::: TTDbl &lt;- typeCheckExp b
    return $ TDblOp dop a' b' ::: TTDbl
</pre>
First we conveniently look up the operator among the arithmetic operators, then we recursively call the type checker for the operands.  We do this in the <tt>Maybe</tt> monad.  If the type checking a subterm fails that's automatically propagated, and furthermore, if the type checking of a subterm does not yield a <tt>TTDbl</tt> type then this will cause the pattern matching to fail, and this will generate a <tt>Nothing</tt> in the maybe monad, so we used failing pattern matching to our advantage here.

The interesting case is checking <tt>UIf</tt>, because here both arms have to have the same type, but we don't know which one.  Here's an attempt:
<pre>
typeCheckExp (UApp "if" [c,t,e]) = do
    c' ::: TTBol &lt;- typeCheckExp c
    t' ::: tt    &lt;- typeCheckExp t
    e' ::: te    &lt;- typeCheckExp e
    guard (tt == te)
    return $ TIf c' t' e' ::: tt
</pre>
But this doesn't type check.  The guard ensures that the two arms have the same type, but that's something we know, but the Haskell type checker doesn't.  So it rejects the <tt>TIf</tt>, because ut can't see that both arms have the same type.  We need to be trickier in doing the equality test so that it reflects the equality on the type level.  There's a standard trick for this, namely this type:
<pre>
data Equal a b where
    Eq :: Equal a a
</pre>
If you ever have a value (which must be <tt>Eq</tt>) of type <tt>Equal foo bar</tt> then the type checker will know that <tt>foo</tt> and <tt>bar</tt> are actually the same type.  So let's code equality for <tt>TTyp</tt>.
<pre>
test :: TTyp a -> TTyp b -> Maybe (Equal a b)
test TTBol TTBol = return Eq
test TTDbl TTDbl = return Eq
test (TTArr a b) (TTArr a' b') = do
    Eq &lt;- test a a'
    Eq &lt;- test b b'
    return Eq
test _ _ = mzero
</pre>
This code is worth pondering for a while, it's actually rather clever (I take no credit for it; I stole it from Tim Sheard).  Why does even the first clause type check?  Because <tt>TTBol</tt> has type <tt>TTyp Bool</tt>, so both the type variables (a and b) must be <tt>TTBool</tt> in the first clause, which means that <tt>Eq :: Equal TBol TBol</tt> is what we're returning.

Equipped with this equality we can try type checking again.
<pre>
typeCheckExp (UApp "if" [c,t,e]) = do
    c' ::: TTBol &lt;- typeCheckExp c
    t' ::: tt    &lt;- typeCheckExp t
    e' ::: te    &lt;- typeCheckExp e
    Eq &lt;- test tt te
    return $ TIf c' t' e' ::: tt
</pre>
And amazingly this actually works!  (A tribute to the hard working ghc implementors.)

One (rather large) fly is left in the ointment.  What about variables?  What do we do when we type check <tt>UVar</tt>?  We must check that there's a bound variable with the right type around.  So the type checker needs to be extended with an environment where variables can be looked up.  It's mostly straight forward.  The environment simply maps a variable to <tt>ATExp</tt>.  So here's the complete type checker as it's actually defined.
<pre>
type Env = [(Id, ATExp)]

typeCheckExp :: Env -> UExp -> Maybe ATExp
typeCheckExp _ (UDbl d) =
    return $ TDbl d ::: TTDbl
typeCheckExp _ (UBol b) =
    return $ TBol b ::: TTBol
typeCheckExp r (UApp op [a, b]) | Just dop &lt;- lookup op [("+", DAdd), ("-", DSub), ("*", DMul), ("/", DDiv)] = do
    a' ::: TTDbl &lt;- typeCheckExp r a
    b' ::: TTDbl &lt;- typeCheckExp r b
    return $ TDblOp dop a' b' ::: TTDbl
typeCheckExp r (UApp op [a, b]) | Just bop &lt;- lookup op [("&&", BAnd), ("||", BOr)] = do
    a' ::: TTBol &lt;- typeCheckExp r a
    b' ::: TTBol &lt;- typeCheckExp r b
    return $ TBolOp bop a' b' ::: TTBol
typeCheckExp r (UApp op [a, b]) | Just cop &lt;- lookup op [("==", CEq), ("&lt;=", CLe)] = do
    a' ::: TTDbl &lt;- typeCheckExp r a
    b' ::: TTDbl &lt;- typeCheckExp r b
    return $ TCmpOp cop a' b' ::: TTBol
typeCheckExp r (UApp "if" [c,t,e]) = do
    c' ::: TTBol &lt;- typeCheckExp r c
    t' ::: tt    &lt;- typeCheckExp r t
    e' ::: te    &lt;- typeCheckExp r e
    Eq &lt;- test tt te
    return $ TIf c' t' e' ::: tt
typeCheckExp r (ULet i e b) = do
    e' ::: te &lt;- typeCheckExp r e
    b' ::: tb &lt;- typeCheckExp ((i, TVar i ::: te) : r) b
    return $ TLet i te e' b' ::: tb
typeCheckExp r (UVar i) =
    lookup i r
typeCheckExp _ _ =
    mzero
</pre>

Note the <tt>ULet</tt> case which extends the environment.  First we type check the expression that's being bound, and then add a variable to the environment and type check the body.

Finally we need to type check the top level:
<pre>
typeCheck :: UFun -> Maybe AFun
typeCheck = typeCheckFun []

typeCheckFun :: Env -> UFun -> Maybe AFun
typeCheckFun n (UFun [] b) = do
    e ::: t &lt;- typeCheckExp n b
    return $ AFun (TBody e) t
typeCheckFun n (UFun ((x, typ):vts) b) =
    case typ of
    UTBol -> f TTBol
    UTDbl -> f TTDbl
  where f t = do AFun e r &lt;- typeCheckFun ((x, TVar x ::: t) : n) (UFun vts b); return $ AFun (TLam x t e) (TTArr t r)
</pre>
When encountering the expression we just type check it, and for an argument we add a variable with the right type to the environment.

A small test in ghci:
<pre>
TExp UExp> mParseUFun "\\ (x::Double) -> x+1" >>= typeCheck
Just (\ (x :: Double) -> x+1.0 :: Double -> Double)
</pre>

To be able to extract a function from <tt>ATFun</tt> we need some small utilties.
<pre>
class Type a where
    theType :: TTyp a
instance Type Double where
    theType = TTDbl
instance Type Bool where
    theType = TTBol
instance (Type a, Type b) => Type (a->b) where
    theType = TTArr theType theType

extractFun :: (Type a) => AFun -> Maybe (TFun a)
extractFun = extract theType

extract :: TTyp a -> AFun -> Maybe (TFun a)
extract s (AFun e t) = do
    Eq &lt;- test t s
    return e

toTFun :: (Type a) => UFun -> Maybe (TFun a)
toTFun = extractFun &lt;=&lt; typeCheck
</pre>
The class <tt>Type</tt> allows us to construct the <tt>TTyp</tt> corresponding to a Haskell type via overloading.  Using this and the <tt>test</tt> function we can then extract a <tt>TFun</tt> at any type we like.  If we try to extract at the wrong type we'll just get <tt>Nothing</tt> and at the right type we get <tt>Just</tt>.

<h3>The Compiler module</h3>
Now all we need to do is to write a function <tt>translate</tt> that translates a <tt>TFun a</tt> into the corresponding <tt>a</tt>.  Naturally, using LLVM.

Let's start with some simple cases in translating literals to LLVM code.
<pre>
compileExp :: TExp a -> CodeGenFunction r (Value a)
compileExp (TDbl d) = return $ valueOf d
compileExp (TBol b) = return $ valueOf b
</pre>

The <tt>valueOf</tt> function is simply the one that lifts a Haskell value into an LLVM value.  Note how nice the GADT works out here and we handle both Double and Bool with any need to compromise type safety.

What about arithmetic?  Equally easy.
<pre>
compileExp r (TDblOp op e1 e2) = bind2 (dblOp op) (compileExp r e1) (compileExp r e2)

dblOp :: DblOp -> Value Double -> Value Double -> CodeGenFunction r (Value Double)
dblOp DAdd = add
dblOp DSub = sub
dblOp DMul = mul
dblOp DDiv = fdiv

-- This should be in Control.Monad
bind2 :: (Monad m) => (a -> b -> m c) -> m a -> m b -> m c
bind2 f m1 m2 = do
    x1 &lt;- m1
    x2 &lt;- m2
    f x1 x2
</pre>

And we can just carry on:
<pre>
compileExp (TBolOp op e1 e2) = bind2 (bolOp op) (compileExp e1) (compileExp e2)
compileExp (TCmpOp op e1 e2) = bind2 (cmpOp op) (compileExp e1) (compileExp e2)
compileExp (TIf b t e) = mkIf (compileExp b) (compileExp t) (compileExp e)

bolOp :: BolOp -> Value Bool -> Value Bool -> CodeGenFunction r (Value Bool)
bolOp BAnd = and
bolOp BOr  = or

cmpOp :: CmpOp -> Value Double -> Value Double -> CodeGenFunction r (Value Bool)
cmpOp CEq = fcmp FPOEQ
cmpOp CLe = fcmp FPOLE
</pre>
(The <tt>&&</tt> and <tt>||</tt> are not short circuiting in this implementation.  It would be easy to change.)

It's rather amazing that despite these different branches producing and consuming different types it all works out.  It's perfectly type safe and free from coercions.  This is the beauty of GADTs.

Oh, yeah, <tt>mkIf</tt>.  It's just a piece of mess to create some basic blocks, test, and jump.
<pre>
mkIf :: (IsFirstClass a) =>
        CodeGenFunction r (Value Bool) -> CodeGenFunction r (Value a) -> CodeGenFunction r (Value a) -> CodeGenFunction r (Value a)
mkIf mb mt me = do
    b &lt;- mb
    tb &lt;- newBasicBlock
    eb &lt;- newBasicBlock
    jb &lt;- newBasicBlock
    condBr b tb eb
    defineBasicBlock tb
    t &lt;- mt
    br jb
    defineBasicBlock eb
    e &lt;- me
    br jb
    defineBasicBlock jb
    phi [(t, tb), (e, eb)]
</pre>

OK, so was lying.  The <tt>translate</tt> function is not quite as easy as that.  Just as with type checking we need an environment because of variables.  It's easy to add though, and here's the real code.

<pre>
compileExp :: (Type a, IsFirstClass a) => Env -> TExp a -> CodeGenFunction r (Value a)
compileExp _ (TDbl d) = return $ valueOf d
compileExp _ (TBol b) = return $ valueOf b
compileExp r (TDblOp op e1 e2) = bind2 (dblOp op) (compileExp r e1) (compileExp r e2)
compileExp r (TBolOp op e1 e2) = bind2 (bolOp op) (compileExp r e1) (compileExp r e2)
compileExp r (TCmpOp op e1 e2) = bind2 (cmpOp op) (compileExp r e1) (compileExp r e2)
compileExp r (TIf b t e) = mkIf (compileExp r b) (compileExp r t) (compileExp r e)
compileExp r (TLet i t e b) = do
    e' &lt;- compileExp' r t e
    compileExp ((i, AValue e' t):r) b
compileExp r (TVar i) = return $ fromJust $ castAValue theType =&lt;&lt; lookup i r   -- lookup cannot fail on type checked code

compileExp' :: Env -> TTyp a -> TExp a -> CodeGenFunction r (Value a)
compileExp' r TTDbl e = compileExp r e
compileExp' r TTBol e = compileExp r e
compileExp' _ _ _ = error $ "compileExp': functions not allowed yet"

data AValue = forall a . AValue (Value a) (TTyp a)

castAValue :: TTyp a -> AValue -> Maybe (Value a)
castAValue t (AValue v s) = do
    Eq &lt;- test t s
    return v

type Env = [(Id, AValue)]
</pre>
Exactly as for the type checking environment we stick the code generation in an environment, and use <tt>castAValue</tt> project it out of the existential container.  The <tt>fromJust</tt> call in the <tt>TVar</tt> case cannot fail on type checked code, but with my string based variable representation I have no evidence of this in the <tt>TExp</tt> so there's actually a cast in the variable case that can fail if scope and type checking has not been performed.  The <tt>compileExp'</tt> is placate the type checker and help it with some evidence about that we are only binding base values.

The rest of the code generation module is just house keeping.  It's a little ugly, but not terrible.
<pre>
-- | Compile a TFun into the corresponding LLVM code.
compileFunction :: (Translate a) =>
                   TFun a -> CodeGenModule (Function (RetIO a))
compileFunction = createFunction ExternalLinkage . compileFun []

class Compile a where
    type CG a
    type RetIO a
    type Returns a
    compileFun :: Env -> TFun a -> CG a

instance Compile Double where
    type CG Double = CodeGenFunction Double ()
    type RetIO Double = IO Double
    type Returns Double = Double
    compileFun r (TBody e) = compileExp r e >>= ret
    -- TLam is not well typed

instance Compile Bool where
    type CG Bool = CodeGenFunction Bool ()
    type RetIO Bool = IO Bool
    type Returns Bool = Bool
    compileFun r (TBody e) = compileExp r e >>= ret
    -- TLam is not well typed

instance (Type a, Compile b) => Compile (a -> b) where
    type CG (a->b) = Value a -> CG b
    type RetIO (a->b) = a -> RetIO b
    type Returns (a->b) = Returns b
    -- TBody is not well typed
    compileFun r (TLam i t e) = \ x -> compileFun ((i, AValue x t):r) e
</pre>
The verbosity and large number of type functions in this section has convinced me that I need to simplify some of the types and classes involved in the LLVM code generation.


To convert and LLVM module we call the JIT.  This produces a function that returns a value in the IO monad (to be on the safe side) so we need to get rid of the IO, and finally we can get rid of the top level IO, because externally what we are doing is really pure (in some sense).

<pre>
translate :: (Translate a) => TFun a -> a
translate = unsafePerformIO . fmap unsafePurify . simpleFunction . compileFunction
</pre>

The <tt>Translate</tt> context is just an abbreviation for a big context enforced by the LLVM functions.  It looks horrendous, but the type checker figured it out for me and I just pasted it in.

<pre>
{-# LANGUAGE TypeFamilies, FlexibleContexts, ExistentialQuantification, FlexibleInstances, UndecidableInstances #-}
module Compile(Translate, translate) where
import Data.Maybe
import Prelude hiding (and, or)
import TExp
import LLVM.Core hiding (CmpOp)
import LLVM.ExecutionEngine
import System.IO.Unsafe(unsafePerformIO)

class    (Type a,
          Unsafe (RetIO a) a,
          FunctionArgs (RetIO a) (CG a) (CodeGenFunction (Returns a) ()),
          IsFunction (RetIO a),
          Compile a,
          Translatable (RetIO a)) =>
    Translate a
instance (Type a,
          Unsafe (RetIO a) a,
          FunctionArgs (RetIO a) (CG a) (CodeGenFunction (Returns a) ()),
          IsFunction (RetIO a),
          Compile a,
          Translatable (RetIO a)) =>
    Translate a
</pre>

<h3>Conclusion</h3>
And that concludes the three parts of the compiler.  In about 400 lines of code we can compile a small subset of Haskell expressions to (efficient) machine code.  After type checking the rest of the processing is done in a type safe manner (except for a cast in <tt>TVar</tt>) which is the intention of the high level LLVM interface.

Oh, and if you instrument the code generator a little you can peek at the machine code being produced.  For instance, for this input to <tt>compile</tt>
<pre>
\ (x::Double) ->
let y = x*(x-1) in
let z = x/y + 1 in
if y &lt;= 0 then 0 else 1/(y-z)
</pre>
we get
<pre>
__fun1:
 subl $12, %esp
 movsd LCPI1_0, %xmm0
 movsd 16(%esp), %xmm1
 movapd %xmm1, %xmm2
 subsd %xmm0, %xmm2
 mulsd %xmm1, %xmm2
 pxor %xmm3, %xmm3
 ucomisd %xmm2, %xmm3
 jae LBB1_3
LBB1_1:
 divsd %xmm2, %xmm1
 addsd %xmm0, %xmm1
 subsd %xmm1, %xmm2
 movsd LCPI1_0, %xmm0
 divsd %xmm2, %xmm0
LBB1_2:
 movsd %xmm0, (%esp)
 fldl (%esp)
 addl $12, %esp
 ret
LBB1_3:
 pxor %xmm0, %xmm0
 jmp LBB1_2
</pre><div style="clear:both; padding-bottom:0.25em"></div>
    </div>
    </div>
    
    <p class="post-footer">
      <em>posted by augustss at <a href="http://augustss.blogspot.com/2009/06/more-llvm-recently-someone-asked-me-on.html" title="permanent link">10:35 PM</a></em>
        <span class="item-control blog-admin pid-1769329649"><a style="border:none;" href="http://www.blogger.com/post-edit.g?blogID=25541020&postID=4910575514980456234" title="Edit Post"><img class="icon-action" alt="" src="http://img2.blogblog.com/img/icon18_edit_allbkg.gif" height="18" width="18"></a></span>
    </p>
  
  </div>
  <!-- End .post -->
  
  
  
  <!-- Begin #comments -->
 
  <div id="comments">

	<a name="comments"></a>
        <h4>4 Comments:</h4>
        <dl id="comments-block">
      
      <dt class="comment-poster" id="c5844492973980056387"><a name="c5844492973980056387"></a>
        <span style="line-height:16px" class="comment-icon blogger-comment-icon"><img src="http://img2.blogblog.com/img/b16-rounded.gif" alt="Blogger" style="display:inline;" /></span>&nbsp;<a href="http://www.blogger.com/profile/13452999182765097159" rel="nofollow">ryani</a> said...
      </dt>
      <dd class="comment-body">

        <p>I love the Maybe (Equal a b) monadic syntax trick.  Although it appears magic, here&#39;s how it works:<br /><br />do {Eq &lt;- expr ; ...}<br />desugars into<br />expr &gt;&gt;= \e -&gt; case e of { Eq -&gt; do {...} }<br /><br />On the inside of the case, we have successfully pattern-matched on Eq :: Equal a b, so the type equality (a ~ b) is in scope; we can use the two types interchangeably!  But the inside of the case is the entire rest of the &quot;do&quot; block, allowing &quot;return Eq&quot; to work.</p>
      </dd>
      <dd class="comment-timestamp"><a href="#5844492973980056387" title="comment permalink">Thursday, June 11, 2009 12:43:00 AM GMT+01:00</a>
	  <span class="item-control blog-admin pid-872165670"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=25541020&postID=5844492973980056387" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
	  </dd>
      
      <dt class="comment-poster" id="c5651472937618671518"><a name="c5651472937618671518"></a>
        <span style="line-height:16px" class="comment-icon blogger-comment-icon"><img src="http://img2.blogblog.com/img/b16-rounded.gif" alt="Blogger" style="display:inline;" /></span>&nbsp;<a href="http://www.blogger.com/profile/09919237195037728981" rel="nofollow">saint</a> said...
      </dt>
      <dd class="comment-body">

        <p>Thanks so much for this extensive post! I was the fellow on #haskell :) I went another route (simpler, with much less type-safety), but this will definitely be on my mind when I go to refactor my existing stuff. Thanks again!</p>
      </dd>
      <dd class="comment-timestamp"><a href="#5651472937618671518" title="comment permalink">Thursday, June 11, 2009 1:41:00 PM GMT+01:00</a>
	  <span class="item-control blog-admin pid-921347307"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=25541020&postID=5651472937618671518" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
	  </dd>
      
      <dt class="comment-poster" id="c5384238505495215727"><a name="c5384238505495215727"></a>
        <span style="line-height:16px" class="comment-icon blogger-comment-icon"><img src="http://img2.blogblog.com/img/b16-rounded.gif" alt="Blogger" style="display:inline;" /></span>&nbsp;<a href="http://www.blogger.com/profile/15462135710203643022" rel="nofollow">meteficha</a> said...
      </dt>
      <dd class="comment-body">

        <p>Nice post, thanks for the insights!</p>
      </dd>
      <dd class="comment-timestamp"><a href="#5384238505495215727" title="comment permalink">Thursday, June 11, 2009 1:48:00 PM GMT+01:00</a>
	  <span class="item-control blog-admin pid-883080728"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=25541020&postID=5384238505495215727" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
	  </dd>
      
      <dt class="comment-poster" id="c8642673246011268178"><a name="c8642673246011268178"></a>
        <span style="line-height:16px" class="comment-icon blogger-comment-icon"><img src="http://img2.blogblog.com/img/b16-rounded.gif" alt="Blogger" style="display:inline;" /></span>&nbsp;<a href="http://www.blogger.com/profile/06069736970788730708" rel="nofollow">Joe Thornber</a> said...
      </dt>
      <dd class="comment-body">

        <p>Thanks for posting this.  It&#39;s nice to see such a complete example.</p>
      </dd>
      <dd class="comment-timestamp"><a href="#8642673246011268178" title="comment permalink">Friday, June 12, 2009 9:36:00 AM GMT+01:00</a>
	  <span class="item-control blog-admin pid-2093679542"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=25541020&postID=8642673246011268178" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
	  </dd>
      
    </dl>
		<p class="comment-timestamp">

    <a class="comment-link" href="https://www.blogger.com/comment.g?blogID=25541020&postID=4910575514980456234">Post a Comment</a>
    </p>
    	    
    


		<p class="comment-timestamp">
	<a href="http://augustss.blogspot.com/">&lt;&lt; Home</a>
    </p>
    </div>



  <!-- End #comments -->


</div></div>
<!-- End #main -->







<!-- Begin #sidebar -->
<div id="sidebar"><div id="sidebar2">
  
  
  <!-- Begin #profile-container -->

   <div id="profile-container"><h2 class="sidebar-title">About Me</h2>
<dl class="profile-datablock">
<dd class="profile-data"><strong>Name:</strong> <a rel="author" href="http://www.blogger.com/profile/07327620522294658036"> Lennart Augustsson </a></dd>
<dd class="profile-data"><strong>Location:</strong>  London, United Kingdom </dd></dl>

<p class="profile-link"><a rel="author" href="http://www.blogger.com/profile/07327620522294658036">View my complete profile</a></p></div>
   
  <!-- End #profile -->
    
        

  
  <h2 class="sidebar-title">Previous Posts</h2>
    <ul id="recently">
    
        <li><a href="http://augustss.blogspot.com/2009/02/more-basic-not-that-anybody-should-care.html">More BASIC
Not that anybody should care, but I&#39;ve ...</a></li>
     
        <li><a href="http://augustss.blogspot.com/2009/02/is-haskell-fast-lets-do-simple.html">Is Haskell fast?
Let&#39;s do a simple benchmark compa...</a></li>
     
        <li><a href="http://augustss.blogspot.com/2009/02/regression-they-say-that-as-you-get.html">Regression

They say that as you get older you reg...</a></li>
     
        <li><a href="http://augustss.blogspot.com/2009/01/performance-update-ive-continued.html">A performance update
I&#39;ve continued playing with t...</a></li>
     
        <li><a href="http://augustss.blogspot.com/2009/01/llvm-arithmetic-so-we-want-to-compute-x.html">LLVM arithmetic
So we want to compute x2-5x+6 usin...</a></li>
     
        <li><a href="http://augustss.blogspot.com/2009/01/llvm-llvm-low-level-virtual-machine-is.html">LLVM
The LLVM, Low Level Virtual Machine, is a rea...</a></li>
     
        <li><a href="http://augustss.blogspot.com/2008/12/ocaml-code-again-im-posting-slight.html">The OCaml code again
I&#39;m posting a slight variatio...</a></li>
     
        <li><a href="http://augustss.blogspot.com/2008/12/abstracting-on-suggested-solutions-i.html">Abstracting on, suggested solutions
I guess I shou...</a></li>
     
        <li><a href="http://augustss.blogspot.com/2008/12/abstraction-continues-i-got-several.html">The abstraction continues
I got several comments t...</a></li>
     
        <li><a href="http://augustss.blogspot.com/2008/12/somewhat-failed-adventure-in-haskell.html">A somewhat failed adventure in Haskell abstraction...</a></li>
     
  </ul>
    

      <p id="powered-by"><a href="http://www.blogger.com"><img src="http://buttons.blogger.com/bloggerbutton1.gif" alt="Powered by Blogger" /></a></p>
  
  <!--
  <p>This is a paragraph of text that could go in the sidebar.</p>
  -->
  


</div></div>
<!-- End #sidebar -->


</div>
<!-- End #content -->



<!-- Begin #footer -->
<div id="footer"><hr />
  <p><!--This is an optional footer. If you want text here, place it inside these tags, and remove this comment. -->&nbsp;</p>

</div>
<!-- End #footer -->



<script type="text/javascript" src="http://www.blogger.com/static/v1/common/js/4153895687-csitail.js"></script>
<script type="text/javascript">BLOG_initCsi('classic_blogspot');</script></body>
</html>