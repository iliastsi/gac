<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>Things that amuse me</title>

  <script type="text/javascript">(function() { var a=window;function c(b){this.t={};this.tick=function(b,i,d){d=d!=void 0?d:(new Date).getTime();this.t[b]=[d,i]};this.tick("start",null,b)}var e=new c;a.jstiming={Timer:c,load:e};try{var g=null;a.chrome&&a.chrome.csi&&(g=Math.floor(a.chrome.csi().pageT));g==null&&a.gtbExternal&&(g=a.gtbExternal.pageT());g==null&&a.external&&(g=a.external.pageT);g&&(a.jstiming.pt=g)}catch(h){};a.tickAboveFold=function(b){var f=0;if(b.offsetParent){do f+=b.offsetTop;while(b=b.offsetParent)}b=f;b<=750&&a.jstiming.load.tick("aft")};var j=!1;function k(){j||(j=!0,a.jstiming.load.tick("firstScrollTime"))}a.addEventListener?a.addEventListener("scroll",k,!1):a.attachEvent("onscroll",k);
 })();</script><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="MSSmartTagsPreventParsing" content="true" />
<meta name="generator" content="Blogger" />
<link rel="icon" type="image/vnd.microsoft.icon" href="http://www.blogger.com/favicon.ico"/>
<link rel="alternate" type="application/atom+xml" title="Things that amuse me - Atom" href="http://augustss.blogspot.com/feeds/posts/default" />
<link rel="alternate" type="application/rss+xml" title="Things that amuse me - RSS" href="http://augustss.blogspot.com/feeds/posts/default?alt=rss" />
<link rel="service.post" type="application/atom+xml" title="Things that amuse me - Atom" href="http://www.blogger.com/feeds/25541020/posts/default" />
<link rel="EditURI" type="application/rsd+xml" title="RSD" href="http://www.blogger.com/rsd.g?blogID=25541020" />
<link rel="alternate" type="application/atom+xml" title="Things that amuse me - Atom" href="http://augustss.blogspot.com/feeds/2319446660716223785/comments/default" />
 <link rel="stylesheet" type="text/css" href="http://www.blogger.com/static/v1/v-css/50269083-blog_controls.css"/> <link rel="stylesheet" type="text/css" href="http://www.blogger.com/dyn-css/authorization.css?targetBlogID=25541020&zx=f7347cf5-ee1a-4763-9dd1-c8c83d4f306e"/>

  <style type="text/css">
/*
-----------------------------------------------
Blogger Template Style
Name:     Minima
Designer: Douglas Bowman
URL:      www.stopdesign.com
Date:     26 Feb 2004
----------------------------------------------- */


body {
  background:#fff;
  margin:0;
  padding:40px 20px;
  font:x-small Georgia,Serif;
  text-align:center;
  color:#333;
  font-size/* */:/**/small;
  font-size: /**/small;
  }
a:link {
  color:#58a;
  text-decoration:none;
  }
a:visited {
  color:#969;
  text-decoration:none;
  }
a:hover {
  color:#c60;
  text-decoration:underline;
  }
a img {
  border-width:0;
  }


/* Header
----------------------------------------------- */
@media all {
  #header {
    width:660px;
    margin:0 auto 10px;
    border:1px solid #ccc;
    }
  }
@media handheld {
  #header {
    width:90%;
    }
  }
#blog-title {
  margin:5px 5px 0;
  padding:20px 20px .25em;
  border:1px solid #eee;
  border-width:1px 1px 0;
  font-size:200%;
  line-height:1.2em;
  font-weight:normal;
  color:#666;
  text-transform:uppercase;
  letter-spacing:.2em;
  }
#blog-title a {
  color:#666;
  text-decoration:none;
  }
#blog-title a:hover {
  color:#c60;
  }
#description {
  margin:0 5px 5px;
  padding:0 20px 20px;
  border:1px solid #eee;
  border-width:0 1px 1px;
  max-width:700px;
  font:78%/1.4em "Trebuchet MS",Trebuchet,Arial,Verdana,Sans-serif;
  text-transform:uppercase;
  letter-spacing:.2em;
  color:#999;
  }


/* Content
----------------------------------------------- */
@media all {
  #content {
    width:660px;
    margin:0 auto;
    padding:0;
    text-align:left;
    }
  #main {
    width:410px;
    float:left;
    }
  #sidebar {
    width:220px;
    float:right;
    }
  }
@media handheld {
  #content {
    width:90%;
    }
  #main {
    width:100%;
    float:none;
    }
  #sidebar {
    width:100%;
    float:none;
    }
  }

/* Headings
----------------------------------------------- */
h2 {
  margin:1.5em 0 .75em;
  font:78%/1.4em "Trebuchet MS",Trebuchet,Arial,Verdana,Sans-serif;
  text-transform:uppercase;
  letter-spacing:.2em;
  color:#999;
  }


/* Posts
----------------------------------------------- */
@media all {
  .date-header {
    margin:1.5em 0 .5em;
    }
  .post {
    margin:.5em 0 1.5em;
    border-bottom:1px dotted #ccc;
    padding-bottom:1.5em;
    }
  }
@media handheld {
  .date-header {
    padding:0 1.5em 0 1.5em;
    }
  .post {
    padding:0 1.5em 0 1.5em;
    }
  }
.post-title {
  margin:.25em 0 0;
  padding:0 0 4px;
  font-size:140%;
  font-weight:normal;
  line-height:1.4em;
  color:#c60;
  }
.post-title a, .post-title a:visited, .post-title strong {
  display:block;
  text-decoration:none;
  color:#c60;
  font-weight:normal;
  }
.post-title strong, .post-title a:hover {
  color:#333;
  }
.post div {
  margin:0 0 .75em;
  line-height:1.6em;
  }
p.post-footer {
  margin:-.25em 0 0;
  color:#ccc;
  }
.post-footer em, .comment-link {
  font:78%/1.4em "Trebuchet MS",Trebuchet,Arial,Verdana,Sans-serif;
  text-transform:uppercase;
  letter-spacing:.1em;
  }
.post-footer em {
  font-style:normal;
  color:#999;
  margin-right:.6em;
  }
.comment-link {
  margin-left:.6em;
  }
.post img {
  padding:4px;
  border:1px solid #ddd;
  }
.post blockquote {
  margin:1em 20px;
  }
.post blockquote p {
  margin:.75em 0;
  }


/* Comments
----------------------------------------------- */
#comments h4 {
  margin:1em 0;
  font:bold 78%/1.6em "Trebuchet MS",Trebuchet,Arial,Verdana,Sans-serif;
  text-transform:uppercase;
  letter-spacing:.2em;
  color:#999;
  }
#comments h4 strong {
  font-size:130%;
  }
#comments-block {
  margin:1em 0 1.5em;
  line-height:1.6em;
  }
#comments-block dt {
  margin:.5em 0;
  }
#comments-block dd {
  margin:.25em 0 0;
  }
#comments-block dd.comment-timestamp {
  margin:-.25em 0 2em;
  font:78%/1.4em "Trebuchet MS",Trebuchet,Arial,Verdana,Sans-serif;
  text-transform:uppercase;
  letter-spacing:.1em;
  }
#comments-block dd p {
  margin:0 0 .75em;
  }
.deleted-comment {
  font-style:italic;
  color:gray;
  }


/* Sidebar Content
----------------------------------------------- */
#sidebar ul {
  margin:0 0 1.5em;
  padding:0 0 1.5em;
  border-bottom:1px dotted #ccc;
  list-style:none;
  }
#sidebar li {
  margin:0;
  padding:0 0 .25em 15px;
  text-indent:-15px;
  line-height:1.5em;
  }
#sidebar p {
  color:#666;
  line-height:1.5em;
  }


/* Profile
----------------------------------------------- */
#profile-container {
  margin:0 0 1.5em;
  border-bottom:1px dotted #ccc;
  padding-bottom:1.5em;
  }
.profile-datablock {
  margin:.5em 0 .5em;
  }
.profile-img {
  display:inline;
  }
.profile-img img {
  float:left;
  padding:4px;
  border:1px solid #ddd;
  margin:0 8px 3px 0;
  }
.profile-data {
  margin:0;
  font:bold 78%/1.6em "Trebuchet MS",Trebuchet,Arial,Verdana,Sans-serif;
  text-transform:uppercase;
  letter-spacing:.1em;
  }
.profile-data strong {
  display:none;
  }
.profile-textblock {
  margin:0 0 .5em;
  }
.profile-link {
  margin:0;
  font:78%/1.4em "Trebuchet MS",Trebuchet,Arial,Verdana,Sans-serif;
  text-transform:uppercase;
  letter-spacing:.1em;
  }


/* Footer
----------------------------------------------- */
#footer {
  width:660px;
  clear:both;
  margin:0 auto;
  }
#footer hr {
  display:none;
  }
#footer p {
  margin:0;
  padding-top:15px;
  font:78%/1.6em "Trebuchet MS",Trebuchet,Verdana,Sans-serif;
  text-transform:uppercase;
  letter-spacing:.1em;
  }
  </style>

<!-- --><style type="text/css">@import url(http://www.blogger.com/static/v1/v-css/navbar/697174003-classic.css);
div.b-mobile {display:none;}
</style>

</head>

<body><script type="text/javascript">
    function setAttributeOnload(object, attribute, val) {
      if(window.addEventListener) {
        window.addEventListener("load",
          function(){ object[attribute] = val; }, false);
      } else {
        window.attachEvent('onload', function(){ object[attribute] = val; });
      }
    }
    function showRelatedContent(args) {
      var el = document.getElementById('related-iframe');
      if (el.parentNode.style.display != 'none') {
        el.parentNode.style.display = 'none';
        document.onclick = showRelatedContent.prevOnClick;
        return;
      }
      
      var match = /(?:^[?]|&)c=([0-9]+)(?:&|(?!.))/.exec(args);
      if (match !== null) {
        document.getElementById('related-loading').style.left = match[1] + 'px';
        el.style.left = Math.max(0, match[1] - parseInt(el.width) / 2) + 'px';
      }
      el.src = "http://www.blogger.com"
          + '/related-content.g?q='
          + window.location.href
          + '&id=' + "25541020";
      el.parentNode.style.display = 'block';
      showRelatedContent.prevOnClick = document.onclick;

      // Hide related-content dropdown when clicking anywhere but on it.
      document.onclick = function() {
        var el = document.getElementById('related-iframe');
        if (el.parentNode.style.display != 'none') {
          el.parentNode.style.display = 'none';
        }
        document.onclick = showRelatedContent.prevOnClick;
      };
    }
  </script>
<iframe src="http://www.blogger.com/navbar.g?targetBlogID=25541020&amp;blogName=Things+that+amuse+me&amp;publishMode=PUBLISH_MODE_BLOGSPOT&amp;navbarType=BLUE&amp;layoutType=CLASSIC&amp;searchRoot=http%3A%2F%2Faugustss.blogspot.com%2Fsearch&amp;blogLocale=en_US&amp;homepageUrl=http%3A%2F%2Faugustss.blogspot.com%2F" marginwidth="0" marginheight="0" scrolling="no" frameborder="0" height="30px" width="100%" id="navbar-iframe" allowtransparency="true" title="Blogger Navigation and Search"></iframe>

<div></div>

<div id="header">

  <h1 id="blog-title">
    <a href="http://augustss.blogspot.com/">
	Things that amuse me
	</a>
  </h1>
  <p id="description"></p>

</div>

<!-- Begin #content -->
<div id="content">


<!-- Begin #main -->
<div id="main"><div id="main2">



    
  <h2 class="date-header">Wednesday, January 07, 2009</h2>
  

  
     
  <!-- Begin .post -->
  <div class="post"><a name="2319446660716223785"></a>
         

	         <div class="post-body">
	<div>
      <div style="clear:both;"></div><h2>LLVM</h2>
The <a href="http://llvm.org/">LLVM</a>, Low Level Virtual Machine, is a really cool compiler infrastructure project with many participants.  The idea is that if you want to make a new high quality compiler you just have to generate LLVM code, and then there are lots of optimizations and code generators available to get fast code.
<p>
There are different ways to generate input to the LLVM tools.  You can generate a text file with LLVM code and feed it to the tools, or you can use bindings for some programming language and programmatically build the LLVM code.  The original bindings from the LLVM project is for C++, but they also provide C bindings.  On top of the C bindings you can easily interface to other languages; for instance O'Caml and Haskell.
<p>
There are also diffent things you can do to LLVM code you have build programmatically.  You can transform it, you can write to a file, you can run an interpreter on it, or execute it with a JIT compiler.

<h3>Haskell LLVM bindings</h3>
There is a Haskell binding to the LLVM.  It has two layers.  You can either work on the C API level and have ample opportunity to shoot your own limbs to pieces, or you can use the high level interface which is mostly safe.
<p>
Bryan O'Sullivan did all the hard work of taking the C header files and producing the corresponding Haskell FFI files.  He also made a first stab at the high level interface, which I have since change a lot (for better or for worse).

<h3>An example</h3>
Let's do an example.  We'll write the LLVM code for this function
<pre>
  f x y z = (x + y) * z
</pre>
In Haskell this function is polymorphic, but when generating machine code we have to settle for a type.  Let's pick <tt>Int32</tt>.  (The Haskell <tt>Int</tt> type cannot be used in talking to LLVM; it doesn't a well defined size.)  Here is how it looks:
<pre>
mAddMul :: CodeGenModule (Function (Int32 -> Int32 -> Int32 -> IO Int32))
mAddMul = 
  createFunction ExternalLinkage $ \ x y z -> do
    t <- add x y
    r <- mul t z
    ret r
</pre>
For comparison, the LLVM code in text for for this would be:
<pre>
define i32 @_fun1(i32, i32, i32) {
        %3 = add i32 %0, %1
        %4 = mul i32 %3, %2
        ret i32 %4
}
</pre>
So what does the Haskell code say? The <tt>mAddMul</tt> definition is something in the <tt>CodeGenModule</tt> monad, and it generates a <tt>Function</tt> of type <tt>Int32 -> Int32 -> Int32 -> IO Int32</tt>.  That last is the type of <tt>f</tt> above, except for that <tt>IO</tt>.  Why the <tt>IO</tt>?  The Haskell LLVM bindings forces all defined functions to return something in the IO monad, because there are no restriction on what can happen in the LLVM code; it might very well do IO.  So to be on the safe side, there's always an IO on the type.  If we know the function is harmless, we can use <tt>unsafePerformIO</tt> to get rid of it.
<p>
So the code does a <tt>createFunction</tt> which does what the name suggests.  The <tt>ExternalLinkage</tt> argument says that this function will be available outside the module it's in, the obvious opposite being <tt>InternalLinkage</tt>.  Using <tt>InternalLinkage</tt> is like saying <tt>static</tt> on the top level in C.  In this examples it doesn't really matter which we pick.
<p>
The function has three arguments <tt>x y z</tt>.  The last argument to <tt>createFunction</tt> should be a lambda expression with the right number of arguments, i.e., the number of arguments should agree with the type.  We the use monadic syntax to generate an <tt>add</tt>, <tt>mul</tt>, and <tt>ret</tt> instruction.
<p>
The code looks like assembly code, which is the level that LLVM is at.  It's a somewhat peculiar assembly code, because it's on SSA (Static Single Assignment) form.  More about that later.
<p>
So what can we do with this function?  Well, we can generate machine code for it and call it.
<pre>
main = do
    addMul <- simpleFunction mAddMul
    a <- addMul 2 3 4
    print a
</pre>
In this code <tt>addMul</tt> has type <tt>Int32 -> Int32 -> Int32 -> IO Int32</tt>, so it has to be called in the IO monad.  Since this is a pure function, we can make the type pure, i.e., <tt>Int32 -> Int32 -> Int32 -> Int32</tt>.
<pre>
main = do
    addMul <- simpleFunction mAddMul
    let addMul' = unsafePurify addMul
    print (addMul' 2 3 4)
</pre>
The <tt>unsafePurify</tt> functions is simply an extension of <tt>unsafePerformIO</tt> that drops the IO on the result of a function.
<p>
So that was pretty easy.  To make a function, just specify the LLVM code using the LLVM DSEL that the Haskell bindings provides.
<h3>Fibonacci</h3>
No FP example is complete without the Fibonacci function, so here it is.
<pre>
mFib :: CodeGenModule (Function (Word32 -> IO Word32))
mFib = do
    fib <- newFunction ExternalLinkage
    defineFunction fib $ \ arg -> do
        -- Create the two basic blocks.
        recurse <- newBasicBlock
        exit <- newBasicBlock

        -- Test if arg > 2
        test <- icmp IntUGT arg (2::Word32)
        condBr test recurse exit

        -- Just return 1 if not > 2
        defineBasicBlock exit
        ret (1::Word32)

        -- Recurse if > 2, using the cumbersome plus to add the results.
        defineBasicBlock recurse
        x1 <- sub arg (1::Word32)
        fibx1 <- call fib x1
        x2 <- sub arg (2::Word32)
        fibx2 <- call fib x2
        r <- add fibx1 fibx2
        ret r
    return fib
</pre>
Instead of using <tt>createFunction</tt> to create the function we're using <tt>newFunction</tt> and <tt>defineFunction</tt>.  The former is a shorthand for the latter two together.  But splitting making the function and actually defining it means that we can refer to the function before it's been defined.  We need this since <tt>fib</tt> is recursive.
<p>
Every instruction in the LLVM code belongs to a basic block.  A basic block is a sequence of non-jump instructions (<tt>call</tt> is allowed in the LLVM) ending with some kind of jump.  It is always entered at the top only.  The top of each basic block can be thought of as a label that you can jump to, and those are the only places that you can jump to.
<p>
The code for fib starts with a test if the argument is Unsigned Greater Than 2.  The <tt>condBr</tt> instruction branches to <tt>recurse</tt> if <tt>test</tt> is true otherwise to <tt>exit</tt>.  To be able to refer to the two branch labels (i.e., basic blocks) before they are defined we create them with <tt>newBasicBlock</tt> and then later define them with <tt>defineBasicBlock</tt>.  The <tt>defineBasicBlock</tt> simply starts a new basic block that runs to the next basic block start, or to the end of the function.  The type system does <b>not</b> check that the basic block ends with a branch (I can't figure out how to do that without making the rest of the code more cumbersome).
<p>
In the false branch we simply return 1, and in the true branch we make the two usual recursive calls, add the results, and return the sum.
<p>
As you can see a few type annotations are necessary on constants.  In my opinion they are quite annoying, because if you write anything different from <tt>::Word32</tt> in those annotations there will be a type error.  This means that in principle the compiler has all the information, it's just too "stupid" to use it.
<p>
The performance you get from this Fibonacci function is decent, but in fact worse than GHC with -O2 gives.  Even with full optimization turned on for the LLVM code it's still not as fast as GHC for this function.
<p>
[Edit: Added assembly] Here is the assembly code for Fibonacci.  Note how there is only one recursive call.  The other call has been transformed into a loop.
<pre>
_fib:
 pushl %edi
 pushl %esi
 subl $4, %esp
 movl 16(%esp), %esi
 cmpl $2, %esi
 jbe LBB1_4
LBB1_1:
 movl $1, %edi
 .align 4,0x90
LBB1_2:
 leal -1(%esi), %eax
 movl %eax, (%esp)
 call _fib
 addl %edi, %eax
 addl $4294967294, %esi
 cmpl $2, %esi
 movl %eax, %edi
 ja LBB1_2
LBB1_3:
 addl $4, %esp
 popl %esi
 popl %edi
 ret
LBB1_4:
 movl $1, %eax
 jmp LBB1_3
</pre>
<h3>Hello, World!</h3>
The code for printing "Hello, World!":
<pre>
import Data.Word
import LLVM.Core
import LLVM.ExecutionEngine

bldGreet :: CodeGenModule (Function (IO ()))
bldGreet = do
    puts <- newNamedFunction ExternalLinkage "puts" :: TFunction (Ptr Word8 -> IO Word32)
    greetz <- createStringNul "Hello, World!"
    func <- createFunction ExternalLinkage $ do
      tmp <- getElementPtr greetz (0::Word32, (0::Word32, ()))
      call puts tmp -- Throw away return value.
      ret ()
    return func

main :: IO ()
main = do
    greet <- simpleFunction bldGreet
    greet
</pre>
To get access to the C function <tt>puts</tt> we simply declare it and rely on the linker to link it in.  The <tt>greetz</tt> variable has type pointer to array of characters.  So to get a pointer to the first character we have to use the rather complicated <tt>getElementPtr</tt> instruction.  See <a href="http://llvm.org/docs/GetElementPtr.html">FAQ about it</a>.

<h3>Phi instructions</h3>
Let's do the following simple C function
<pre>
int f(int x)
{
  if (x < 0) x = -x;
  return (x+1);
}
</pre>
Let's try to write some corresponding LLVM code:
<pre>
  createFunction ExternalLinkage $ \ x -> do
    xneg <- newBasicBlock
    xpos <- newBasicBlock
    t <- icmp IntSLT x (0::Int32)
    condBr t xneg xpos

    defineBasicBlock xneg
    x' <- sub (0::Int32) x
    br xpos

    defineBasicBlock xpos
    r1 <- add ??? (1::Int32)
    ret r1
</pre>
But what should we put at <tt>???</tt>?  When jumping from the <tt>condBr</tt> the value is in <tt>x</tt>, but when jumping from the negation block the value is in <tt>x'</tt>.  And this is how SSA works.  Every instruction puts the value in a new "register", so this situation is unavoidable.  This is why SSA (and thus LLVM) form has <tt>phi</tt> instructions.  This is a pseudo-instruction to tell the code generator what registers should be merged at the entry of a basic block.  So the real code looks like this:
<pre>
mAbs1 :: CodeGenModule (Function (Int32 -> IO Int32))
mAbs1 = 
  createFunction ExternalLinkage $ \ x -> do
    top <- getCurrentBasicBlock
    xneg <- newBasicBlock
    xpos <- newBasicBlock
    t <- icmp IntSLT x (0::Int32)
    condBr t xneg xpos

    defineBasicBlock xneg
    x' <- sub (0::Int32) x
    br xpos

    defineBasicBlock xpos
    r <- phi [(x, top), (x', xneg)]
    r1 <- add r (1::Int32)
    ret r1
</pre>
The <tt>phi</tt> instruction takes a list of registers to merge, and paired up with each register is the basic block that the jump comes from.  Since the first basic block in a function is created implicitely we have to get it with <tt>getCurrentBasicBlock</tt> which returns the current basic block.
<p>
If, like me, you have a perverse interest in the machine code that gets generated here is the optimized code for that function on for x86:
<pre>
__fun1:
        movl    4(%esp), %eax
        movl    %eax, %ecx
        sarl    $31, %ecx
        addl    %ecx, %eax
        xorl    %ecx, %eax
        incl    %eax
        ret
</pre>
Note how the conditional jump has cleverly been replaced by some non-jumping instructions.  I think this code is as good as it gets.
<p>

<h3>Loops and arrays</h3>
Let's do a some simple array code, the dot product of two vectors.  The function takes a length and pointers to two vectors.  It sums the elementwise product of the vectors.  Here's the C code:
<pre>
double
dotProd(unsigned int len, double *aPtr, double *bPtr)
{
    unsigned int i;
    double s;

    s = 0;
    for (i = 0; i != len; i++)
        s += aPtr[i] * bPtr[i];
    return s;
}
</pre>
The corresponding LLVM code is much more complicated and has some new twists.
<pre>
import Data.Word
import Foreign.Marshal.Array
import LLVM.Core
import LLVM.ExecutionEngine

mDotProd :: CodeGenModule (Function (Word32 -> Ptr Double -> Ptr Double -> IO Double))
mDotProd =
  createFunction ExternalLinkage $ \ size aPtr bPtr -> do
    top <- getCurrentBasicBlock
    loop <- newBasicBlock
    body <- newBasicBlock
    exit <- newBasicBlock

    -- Enter loop, must use a br since control flow joins at the loop bb.
    br loop

    -- The loop control.
    defineBasicBlock loop
    i <- phi [(valueOf (0 :: Word32), top)]  -- i starts as 0, when entered from top bb
    s <- phi [(valueOf 0, top)]  -- s starts as 0, when entered from top bb
    t <- icmp IntNE i size       -- check for loop termination
    condBr t body exit

    -- Define the loop body
    defineBasicBlock body

    ap <- getElementPtr aPtr (i, ()) -- index into aPtr
    bp <- getElementPtr bPtr (i, ()) -- index into bPtr
    a <- load ap                 -- load element from a vector
    b <- load bp                 -- load element from b vector
    ab <- mul a b                -- multiply them
    s' <- add s ab               -- accumulate sum

    i' <- add i (valueOf (1 :: Word32)) -- Increment loop index

    addPhiInputs i [(i', body)]  -- Control flow reaches loop bb from body bb
    addPhiInputs s [(s', body)]
    br loop                      -- And loop

    defineBasicBlock exit
    ret (s :: Value Double)      -- Return sum

main = do
    ioDotProd <- simpleFunction mDotProd
    let dotProd a b =
         unsafePurify $
         withArrayLen a $ \ aLen aPtr ->
         withArrayLen b $ \ bLen bPtr ->
         ioDotProd (fromIntegral (aLen `min` bLen)) aPtr bPtr

    let a = [1,2,3]
        b = [4,5,6]
    print $ dotProd a b
    print $ sum $ zipWith (*) a b
</pre>
First we have to set up the looping machinery.  There a four basic blocks involved: the implicit basic block that is created at the start of every function, <tt>top</tt>; the top of the loop, <tt>loop</tt>; the body of the loop, <tt>body</tt>; and finally the block with the return from the function, <tt>exit</tt>.
<p>
There are two "registers", the loop index <tt>i</tt> and the running sum <tt>s</tt> that arrive from two different basic blocks at the top of the loop.  When entering the loop from the first time they should be 0.  That's what the <tt>phi</tt> instruction specifies.  The <tt>valueOf</tt> function simply turns a constant into an LLVM value.  It's worth noting that the initial values for the two variables are constant rather than registers.  The control flow also reached the basic block <tt>loop</tt> from the end of <tt>body</tt>, but we don't have the names of those registers in scope yet, so we can't put them in the <tt>phi</tt> instruction.  Instead, we have to use <tt>addPhiInputs</tt> to add more phi inputs later (when the registers are in scope).
<p>
The most mysterious instruction in the LLVM is <tt>getElementPtr</tt>.  It simply does address arithmetic, so it really does something quite simple.  But it can perform several levels of address arithmetic when addressing through multilevel arrays and structs.  In can take several indicies, but since here we simply want to add the index variable to a pointer the usage is pretty simple.  Doing <tt>getElementPtr aPtr (i, ())</tt> corresponds to <tt>aPtr + i</tt> in C.
<p>
To test this function we need pointers to two vectors.  The FFI function <tt>withArrayLen</tt> temporarily allocates the vector and fills it with elements from the list.
<p>
The essential part of the function looks like this in optimized x86 code:
<pre>
        pxor    %xmm0, %xmm0
        xorl    %esi, %esi
        .align  4,0x90
LBB1_2:
        movsd   (%edx,%esi,8), %xmm1
        mulsd   (%ecx,%esi,8), %xmm1
        incl    %esi
        cmpl    %eax, %esi
        addsd   %xmm1, %xmm0
        jne     LBB1_2
</pre>
Which is pretty good.  Improving this would have to use SSD vector instructions.  This is possible using the LLVM vector type, but I'll leave that for now.
<h3>Abstraction</h3>
The loop structure in <tt>dotProd</tt> is pretty common, so we would like to abstract it out for reuse.  The creation of basic blocks and phi instructions is rather fiddly so it would be nice to do this once and not worry about it again.
<p>
What are the parts of the loop?  Well, let's just do a simple "for" loop that loops from a lower index (inclusive) to an upper index (exclusive) and executes the loop body for each iteration.  So there should be three arguments to the loop function: lower bound, upper bound and loop body.  What is the loop body?  Since the LLVM is using SSA the loop body can't really update the loop state variables.  Instead it's like a pure functional language where you have to express it as a state transformation.  So the loop body will take the old state and return a new state.  It's also useful to pass the loop index to the loop body.  Now when we've introduced the notion of a loop state we also need to have an initial value for the loop state as an argument to the loop function.
<p>
Let's start out easy and let the state to be updated in the loop be a single value.  In <tt>dotProd</tt> it's simply the running sum (<tt>s</tt>).
<pre>
forLoop low high start incr = do
    top <- getCurrentBasicBlock
    loop <- newBasicBlock
    body <- newBasicBlock
    exit <- newBasicBlock

    br loop

    defineBasicBlock loop
    i <- phi [(low, top)]
    state <- phi [(start, top)]
    t <- icmp IntNE i high
    condBr t body exit

    defineBasicBlock body

    state' <- incr i state
    i' <- add i (valueOf 1)

    body' <- getCurrentBasicBlock
    addPhiInputs i [(i', body')]
    addPhiInputs state [(state', body')]
    br loop
    defineBasicBlock exit

    return state
</pre>
The <tt>low</tt> and <tt>high</tt> arguments are simply the loop bounds, <tt>start</tt> is the start value for the loop state variable, and finally <tt>incr</tt> is invoked in the loop body to get the new value for the state variable.  Note that the <tt>incr</tt> can contain new basic blocks so there's no guarantee we're in the same basic block after <tt>incr</tt> has been called.  That's why there is a call to <tt>getCurrentBasicBlock</tt> before adding to the phi instructions.
<p>
So the original loop in <tt>dotProd</tt> can now be written
<pre>
    s <- forLoop 0 size 0 $ \ i s -> do
      ap <- getElementPtr aPtr (i, ()) -- index into aPtr
      bp <- getElementPtr bPtr (i, ()) -- index into bPtr
      a <- load ap                 -- load element from a vector
      b <- load bp                 -- load element from b vector
      ab <- mul a b                -- multiply them
      s' <- add s ab               -- accumulate sum
      return s'
</pre>
So that wasn't too bad.  But what if the loop needs multiple state variables?  Or none?  The tricky bit is handling the phi instructions since the number of instructions needed depends on how many state variables we have.  So let's creat a class for types that can be state variables.  This way we can use tuples for multiple state variables.  The class needs two methods, the generalization of <tt>phi</tt> and the generalization of <tt>addPhiInputs</tt>.
<pre>
class Phi a where
    phis :: BasicBlock -> a -> CodeGenFunction r a
    addPhis :: BasicBlock -> a -> a -> CodeGenFunction r ()
</pre>
A simple instance is when we have no state variables.
<pre>
instance Phi () where
    phis _ _ = return ()
    addPhis _ _ _ = return ()
</pre>
We also need to handle the case with a single state variable.  All LLVM values are encapsulated in the <tt>Value</tt> type, so this is the one we create an instance for.
<pre>
instance (IsFirstClass a) => Phi (Value a) where
    phis bb a = do
        a' <- phi [(a, bb)]
        return a'
    addPhis bb a a' = do
        addPhiInputs a [(a', bb)]
</pre>
Finally, here's the instance for pair.  Other tuples can be done in the same way (or we could just use nested pairs).
<pre>
instance (Phi a, Phi b) => Phi (a, b) where
    phis bb (a, b) = do
        a' <- phis bb a
        b' <- phis bb b
        return (a', b')
    addPhis bb (a, b) (a', b') = do
        addPhis bb a a'
        addPhis bb b b'
</pre>
Using this new class the looping function becomes
<pre>
forLoop :: forall i a r . (Phi a, Num i, IsConst i, IsInteger i, IsFirstClass i) =>
           Value i -> Value i -> a -> (Value i -> a -> CodeGenFunction r a) -> CodeGenFunction r a
forLoop low high start incr = do
    top <- getCurrentBasicBlock
    loop <- newBasicBlock
    body <- newBasicBlock
    exit <- newBasicBlock

    br loop

    defineBasicBlock loop
    i <- phi [(low, top)]
    vars <- phis top start
    t <- icmp IntNE i high
    condBr t body exit

    defineBasicBlock body

    vars' <- incr i vars
    i' <- add i (valueOf 1 :: Value i)

    body' <- getCurrentBasicBlock
    addPhis body' vars vars'
    addPhiInputs i [(i', body')]
    br loop
    defineBasicBlock exit

    return vars
</pre>
<h3>File operations</h3>
The Haskell bindings provide two convenient functions - <tt>writeBitcodeToFile</tt> and <tt>readBitcodeFromFile</tt> - for writing and reading modules in the LLVM binary format.
<p>
A simple example:
<pre>
import Data.Int
import LLVM.Core

mIncr :: CodeGenModule (Function (Int32 -> IO Int32))
mIncr = 
  createNamedFunction ExternalLinkage "incr" $ \ x -> do
    r <- add x (1 :: Int32)
    ret r

main = do
    m <- newModule
    defineModule m mIncr
    writeBitcodeToFile "incr.bc" m
</pre>
Running this will produce the file <tt>incr.bc</tt> which can be processed with the usual LLVM tools.  E.g.
<pre>
$ llvm-dis < incr.bc  # to look at the LLVM code
$ opt -std-compile-opts incr.bc -f -o incrO.bc # run optimizer
$ llvm-dis < incrO.bc  # to look at the optimized LLVM code
$ llc incrO.bc # generate assembly code
$ cat incrO.s  # look at assembly code
</pre>
Reading a module file is equally easy, but what can you do with a module you have read?  It could contain anything.  To extract things from a module there is a function <tt>getModuleValues</tt> which returns a list of name-value pairs of all externally visible functions and global variables.  The values all have type <tt>ModuleValue</tt>.  To convert a <tt>ModuleValue</tt> to a regular <tt>Value</tt> you have to use <tt>castModuleValue</tt>.  This is a safe conversion function that makes a dynamic type test to make sure the types match (think of <tt>ModuleValue</tt> as <tt>Dynamic</tt> and <tt>castModuleValue</tt> as <tt>fromDynamic</tt>).
<p>
Here's an example:
<pre>
import Data.Int
import LLVM.Core
import LLVM.ExecutionEngine

main = do
    m <- readBitcodeFromFile "incr.bc"
    ee <- createModuleProviderForExistingModule m >>= createExecutionEngine
    funcs <- getModuleValues m
    let ioincr :: Function (Int32 -> IO Int32)
        Just ioincr = lookup "incr" funcs >>= castModuleValue
        incr = unsafePurify $ generateFunction ee ioincr

    print (incr 41)
</pre>
This post is getting rather long, so I'll let this be the last example for today.<div style="clear:both; padding-bottom:0.25em"></div><p class="blogger-labels">Labels: <a rel='tag' href="http://augustss.blogspot.com/search/label/Code%20generation">Code generation</a>, <a rel='tag' href="http://augustss.blogspot.com/search/label/DSL">DSL</a>, <a rel='tag' href="http://augustss.blogspot.com/search/label/Haskell">Haskell</a>, <a rel='tag' href="http://augustss.blogspot.com/search/label/LLVM">LLVM</a></p>
    </div>
    </div>
    
    <p class="post-footer">
      <em>posted by augustss at <a href="http://augustss.blogspot.com/2009/01/llvm-llvm-low-level-virtual-machine-is.html" title="permanent link">4:14 PM</a></em>
        <span class="item-control blog-admin pid-1769329649"><a style="border:none;" href="http://www.blogger.com/post-edit.g?blogID=25541020&postID=2319446660716223785" title="Edit Post"><img class="icon-action" alt="" src="http://img2.blogblog.com/img/icon18_edit_allbkg.gif" height="18" width="18"></a></span>
    </p>
  
  </div>
  <!-- End .post -->
  
  
  
  <!-- Begin #comments -->
 
  <div id="comments">

	<a name="comments"></a>
        <h4>17 Comments:</h4>
        <dl id="comments-block">
      
      <dt class="comment-poster" id="c3855342589647819560"><a name="c3855342589647819560"></a>
        <span style="line-height:16px" class="comment-icon blogger-comment-icon"><img src="http://img2.blogblog.com/img/b16-rounded.gif" alt="Blogger" style="display:inline;" /></span>&nbsp;<a href="http://www.blogger.com/profile/05756984502464196668" rel="nofollow">Conal</a> said...
      </dt>
      <dd class="comment-body">

        <p>Cool!  Does simpleFunction really have to be in IO?</p>
      </dd>
      <dd class="comment-timestamp"><a href="#3855342589647819560" title="comment permalink">Wednesday, January 7, 2009 8:05:00 PM GMT</a>
	  <span class="item-control blog-admin pid-543787737"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=25541020&postID=3855342589647819560" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
	  </dd>
      
      <dt class="comment-poster" id="c2509241738153088705"><a name="c2509241738153088705"></a>
        <span style="line-height:16px" class="comment-icon blogger-comment-icon"><img src="http://img2.blogblog.com/img/b16-rounded.gif" alt="Blogger" style="display:inline;" /></span>&nbsp;<a href="http://www.blogger.com/profile/07327620522294658036" rel="nofollow">augustss</a> said...
      </dt>
      <dd class="comment-body">

        <p>I think simpleFunction fits best in IO, because the whole LLVM framework is in IO.  There are various effects going on.</p>
      </dd>
      <dd class="comment-timestamp"><a href="#2509241738153088705" title="comment permalink">Wednesday, January 7, 2009 8:14:00 PM GMT</a>
	  <span class="item-control blog-admin pid-1769329649"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=25541020&postID=2509241738153088705" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
	  </dd>
      
      <dt class="comment-poster" id="c2800364050389295140"><a name="c2800364050389295140"></a>
        <span style="line-height:16px" class="comment-icon blogger-comment-icon"><img src="http://img2.blogblog.com/img/b16-rounded.gif" alt="Blogger" style="display:inline;" /></span>&nbsp;<a href="http://www.blogger.com/profile/05756984502464196668" rel="nofollow">Conal</a> said...
      </dt>
      <dd class="comment-body">

        <p>Thanks for the reply, Lennart.  I guess I'm looking for a "no" or more compelling "yes".  Here's my thought process:<BR/><BR/>In pure lazy functional programming, there are always effects going on, such as thunk updating and stack frame munging.  We've figured out how to encapsulate those effects behind simple functional semantics, which then means we can have tractable rigorous reasoning and terrific modularity.  When other effects come along, I like to see if they can also be wrapped up as the implementation of a semantically simple abstraction.  The LLVM framework looks fun and useful, so naturally I'd like that it be available functionally if possible.<BR/><BR/>So I guess a clearer form of my question is as follows.<BR/><BR/>Is there a semantic obstacle to simpleFunction producing indistinguishable results on successive calls with the same argument?<BR/><BR/>If not, how can LLVM be packaged safely, simply, and functionally (IO-free interface/semantics)?</p>
      </dd>
      <dd class="comment-timestamp"><a href="#2800364050389295140" title="comment permalink">Wednesday, January 7, 2009 11:25:00 PM GMT</a>
	  <span class="item-control blog-admin pid-543787737"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=25541020&postID=2800364050389295140" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
	  </dd>
      
      <dt class="comment-poster" id="c7388256053981611252"><a name="c7388256053981611252"></a>
        <span style="line-height:16px" class="comment-icon blogger-comment-icon"><img src="http://img2.blogblog.com/img/b16-rounded.gif" alt="Blogger" style="display:inline;" /></span>&nbsp;<a href="http://www.blogger.com/profile/16509408666213777114" rel="nofollow">kyle</a> said...
      </dt>
      <dd class="comment-body">

        <p>Mind posting the assembly for LLVM fibonacci function?</p>
      </dd>
      <dd class="comment-timestamp"><a href="#7388256053981611252" title="comment permalink">Wednesday, January 7, 2009 11:59:00 PM GMT</a>
	  <span class="item-control blog-admin pid-773915254"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=25541020&postID=7388256053981611252" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
	  </dd>
      
      <dt class="comment-poster" id="c3436092851701251831"><a name="c3436092851701251831"></a>
        <span style="line-height:16px" class="comment-icon blogger-comment-icon"><img src="http://img2.blogblog.com/img/b16-rounded.gif" alt="Blogger" style="display:inline;" /></span>&nbsp;<a href="http://www.blogger.com/profile/08018983019271676117" rel="nofollow">Harold Fowler</a> said...
      </dt>
      <dd class="comment-body">

        <p>Wow, totally mind boggling!<BR/><BR/>www.privacy.de.tc</p>
      </dd>
      <dd class="comment-timestamp"><a href="#3436092851701251831" title="comment permalink">Thursday, January 8, 2009 1:19:00 AM GMT</a>
	  <span class="item-control blog-admin pid-609484516"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=25541020&postID=3436092851701251831" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
	  </dd>
      
      <dt class="comment-poster" id="c1501499431494541038"><a name="c1501499431494541038"></a>
        <span style="line-height:16px" class="comment-icon blogger-comment-icon"><img src="http://img2.blogblog.com/img/b16-rounded.gif" alt="Blogger" style="display:inline;" /></span>&nbsp;<a href="http://www.blogger.com/profile/02173506978646246705" rel="nofollow">jag</a> said...
      </dt>
      <dd class="comment-body">

        <p>Where you start looking at abstracting the for-loop, I think there&#39;s a typo:<BR/><BR/>  state &lt;- phi [(state, top)]<BR/><BR/>The second &quot;state&quot; should be &quot;start&quot;.</p>
      </dd>
      <dd class="comment-timestamp"><a href="#1501499431494541038" title="comment permalink">Thursday, January 8, 2009 2:43:00 AM GMT</a>
	  <span class="item-control blog-admin pid-1027269131"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=25541020&postID=1501499431494541038" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
	  </dd>
      
      <dt class="comment-poster" id="c2840513991454754134"><a name="c2840513991454754134"></a>
        <span style="line-height:16px" class="comment-icon blogger-comment-icon"><img src="http://img2.blogblog.com/img/b16-rounded.gif" alt="Blogger" style="display:inline;" /></span>&nbsp;<a href="http://www.blogger.com/profile/07327620522294658036" rel="nofollow">augustss</a> said...
      </dt>
      <dd class="comment-body">

        <p>Conal:  Right now the code generation monads belong to MonadIO so you can do arbitrary effects in there.  This isn't necessary and could be removed.<BR/>Assuming that this was removed I see no fundamental reason why simpleFunction couldn't be a pure function (it isn't now, in fact calling it a second time would probably make the program crash because of how the LLVM execution engine works).</p>
      </dd>
      <dd class="comment-timestamp"><a href="#2840513991454754134" title="comment permalink">Thursday, January 8, 2009 7:50:00 AM GMT</a>
	  <span class="item-control blog-admin pid-1769329649"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=25541020&postID=2840513991454754134" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
	  </dd>
      
      <dt class="comment-poster" id="c5419221658894852461"><a name="c5419221658894852461"></a>
        <span style="line-height:16px" class="comment-icon blogger-comment-icon"><img src="http://img2.blogblog.com/img/b16-rounded.gif" alt="Blogger" style="display:inline;" /></span>&nbsp;<a href="http://www.blogger.com/profile/07327620522294658036" rel="nofollow">augustss</a> said...
      </dt>
      <dd class="comment-body">

        <p>kyle: assembly code added.</p>
      </dd>
      <dd class="comment-timestamp"><a href="#5419221658894852461" title="comment permalink">Thursday, January 8, 2009 7:50:00 AM GMT</a>
	  <span class="item-control blog-admin pid-1769329649"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=25541020&postID=5419221658894852461" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
	  </dd>
      
      <dt class="comment-poster" id="c5187774648798854865"><a name="c5187774648798854865"></a>
        <span style="line-height:16px" class="comment-icon blogger-comment-icon"><img src="http://img2.blogblog.com/img/b16-rounded.gif" alt="Blogger" style="display:inline;" /></span>&nbsp;<a href="http://www.blogger.com/profile/07327620522294658036" rel="nofollow">augustss</a> said...
      </dt>
      <dd class="comment-body">

        <p>jag: thanks, fixed.</p>
      </dd>
      <dd class="comment-timestamp"><a href="#5187774648798854865" title="comment permalink">Thursday, January 8, 2009 7:50:00 AM GMT</a>
	  <span class="item-control blog-admin pid-1769329649"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=25541020&postID=5187774648798854865" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
	  </dd>
      
      <dt class="comment-poster" id="c6111255623583069793"><a name="c6111255623583069793"></a>
        <span style="line-height:16px" class="comment-icon blogger-comment-icon"><img src="http://img2.blogblog.com/img/b16-rounded.gif" alt="Blogger" style="display:inline;" /></span>&nbsp;<a href="http://www.blogger.com/profile/16862546723726662511" rel="nofollow">Ganesh Sittampalam</a> said...
      </dt>
      <dd class="comment-body">

        <p>The homepage link on http://hackage.haskell.org/cgi-bin/hackage-scripts/package/llvm is broken.</p>
      </dd>
      <dd class="comment-timestamp"><a href="#6111255623583069793" title="comment permalink">Thursday, January 8, 2009 9:15:00 AM GMT</a>
	  <span class="item-control blog-admin pid-1719495597"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=25541020&postID=6111255623583069793" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
	  </dd>
      
      <dt class="comment-poster" id="c3605386717058900005"><a name="c3605386717058900005"></a>
        <span style="line-height:16px" class="comment-icon blogger-comment-icon"><img src="http://img2.blogblog.com/img/b16-rounded.gif" alt="Blogger" style="display:inline;" /></span>&nbsp;<a href="http://www.blogger.com/profile/02978139250264605147" rel="nofollow">Lauri</a> said...
      </dt>
      <dd class="comment-body">

        <p>LLVM is very very cool. I've been writing a compiler for Appel's Tiger language in Haskell in my spare time and I planning on using the Haskell LLVM bindings when implementing the backend (after first writing my own code gen phase as a learning experience - nothing quite as exciting as adding optimisations to your own code generator ;-).<BR/><BR/>Thanks for the great work!<BR/><BR/>-- Lauri</p>
      </dd>
      <dd class="comment-timestamp"><a href="#3605386717058900005" title="comment permalink">Thursday, January 8, 2009 1:54:00 PM GMT</a>
	  <span class="item-control blog-admin pid-2138375271"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=25541020&postID=3605386717058900005" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
	  </dd>
      
      <dt class="comment-poster" id="c3109711539365864228"><a name="c3109711539365864228"></a>
        <span style="line-height:16px" class="comment-icon blogger-comment-icon"><img src="http://img2.blogblog.com/img/b16-rounded.gif" alt="Blogger" style="display:inline;" /></span>&nbsp;<a href="http://www.blogger.com/profile/12815885586546829336" rel="nofollow">Bas van Dijk</a> said...
      </dt>
      <dd class="comment-body">

        <p>Nice!<BR/><BR/>Have you considered using circular programming techniques using recursive do?<BR/><BR/>Which is described by Russell O'Connor in his paper "Circular Programming with Recursive do" in <A HREF="http://www.haskell.org/sitewiki/images/1/14/TMR-Issue6.pdf" REL="nofollow">The Monad Reader issue 6</A><BR/><BR/>Maybe this will allow you to refer to blocks <B>before</B> they are defined. Which allows you to remove the <I>newBasicBlock</I>s. <BR/><BR/>Here's an "artist impression" of your <I>fib</I> for example:<BR/><BR/>(sorry for the absent indentation, I couldn't figure out how to insert literate code into Blogger)<BR/><I><BR/>mFib = do<BR/>    fib &lt;- newFunction ExternalLinkage<BR/>    defineFunction fib $ \ arg -&gt; <B>mdo</B><BR/><BR/>        test &lt;- icmp IntUGT arg (2::Word32)<BR/>        condBr test <B>recurse</B> <B>exit</B><BR/><BR/>        <B>recurse</B> &lt;- defineBasicBlock $ <BR/>                   do x1 &lt;- sub arg (1::Word32)<BR/>                      fibx1 &lt;- call fib x1<BR/>                      x2 &lt;- sub arg (2::Word32)<BR/>                      fibx2 &lt;- call fib x2<BR/>                      r &lt;- add fibx1 fibx2<BR/>                      ret r<BR/><BR/>        <B>exit</B> &lt;- defineBasicBlock $ ret (1::Word32)<BR/>    return fib<BR/></I></p>
      </dd>
      <dd class="comment-timestamp"><a href="#3109711539365864228" title="comment permalink">Thursday, January 8, 2009 8:42:00 PM GMT</a>
	  <span class="item-control blog-admin pid-1250177276"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=25541020&postID=3109711539365864228" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
	  </dd>
      
      <dt class="comment-poster" id="c7670575680778283221"><a name="c7670575680778283221"></a>
        <span style="line-height:16px" class="comment-icon blogger-comment-icon"><img src="http://img2.blogblog.com/img/b16-rounded.gif" alt="Blogger" style="display:inline;" /></span>&nbsp;<a href="http://www.blogger.com/profile/05756984502464196668" rel="nofollow">Conal</a> said...
      </dt>
      <dd class="comment-body">

        <p>Making code generation available from functional code (consistent with its referential transparency) would sure make it available in more circumstances and more compositionally, and hence more useful to me (and I assume others).<BR/><BR/>"<EM>calling it a second time would probably make the program crash because of how the LLVM execution engine works</EM>"<BR/><BR/>Yow!  Can this problem be fixed?</p>
      </dd>
      <dd class="comment-timestamp"><a href="#7670575680778283221" title="comment permalink">Friday, January 9, 2009 7:08:00 AM GMT</a>
	  <span class="item-control blog-admin pid-543787737"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=25541020&postID=7670575680778283221" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
	  </dd>
      
      <dt class="comment-poster" id="c1620315611362545756"><a name="c1620315611362545756"></a>
        <span style="line-height:16px" class="comment-icon blogger-comment-icon"><img src="http://img2.blogblog.com/img/b16-rounded.gif" alt="Blogger" style="display:inline;" /></span>&nbsp;<a href="http://www.blogger.com/profile/07327620522294658036" rel="nofollow">augustss</a> said...
      </dt>
      <dd class="comment-body">

        <p>Bas: I used recursive do in my Harpy experiments.  It looked similar to what you describe.  I've not tried it yet for LLVM.<BR/><BR/>Conal: I think I've fixed execution engine problems in the LLVM bindings now by changing the interface.  And I'll think about making a pure code generation interface.</p>
      </dd>
      <dd class="comment-timestamp"><a href="#1620315611362545756" title="comment permalink">Saturday, January 10, 2009 10:18:00 AM GMT</a>
	  <span class="item-control blog-admin pid-1769329649"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=25541020&postID=1620315611362545756" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
	  </dd>
      
      <dt class="comment-poster" id="c3915236295267461701"><a name="c3915236295267461701"></a>
        <span style="line-height:16px" class="comment-icon blogger-comment-icon"><img src="http://img2.blogblog.com/img/b16-rounded.gif" alt="Blogger" style="display:inline;" /></span>&nbsp;<a href="http://www.blogger.com/profile/08018421791257662632" rel="nofollow">cuntface</a> said...
      </dt>
      <dd class="comment-body">

        <p><span class="deleted-comment">This post has been removed by the author.</span></p>
      </dd>
      <dd class="comment-timestamp"><a href="#3915236295267461701" title="comment permalink">Saturday, February 21, 2009 6:58:00 PM GMT</a>
	  <span class="item-control blog-admin "><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=25541020&postID=3915236295267461701" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
	  </dd>
      
      <dt class="comment-poster" id="c6530235106763652508"><a name="c6530235106763652508"></a>
        <span style="line-height:16px" class="comment-icon blogger-comment-icon"><img src="http://img2.blogblog.com/img/b16-rounded.gif" alt="Blogger" style="display:inline;" /></span>&nbsp;<a href="http://www.blogger.com/profile/08018421791257662632" rel="nofollow">jay</a> said...
      </dt>
      <dd class="comment-body">

        <p>Are you able to advise which version of GHC you're using for this? I have LLVM 2.4 and GHC 6.8.3, along with the bindings 0.6.4.0, but unfortunately I keep getting link errors when I try anything (including the code in the examples/ directory). This is despite a verbose output indicating the appropriate link flags *are* being called by ghc :(</p>
      </dd>
      <dd class="comment-timestamp"><a href="#6530235106763652508" title="comment permalink">Saturday, February 21, 2009 7:15:00 PM GMT</a>
	  <span class="item-control blog-admin pid-1995171743"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=25541020&postID=6530235106763652508" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
	  </dd>
      
      <dt class="comment-poster" id="c831071325042142051"><a name="c831071325042142051"></a>
        <span style="line-height:16px" class="comment-icon blogger-comment-icon"><img src="http://img2.blogblog.com/img/b16-rounded.gif" alt="Blogger" style="display:inline;" /></span>&nbsp;<a href="http://www.blogger.com/profile/17264379488083302719" rel="nofollow">blog for steveLi</a> said...
      </dt>
      <dd class="comment-body">

        <p>In pure lazy functional programming, there are always effects going on, such as thunk updating and stack frame munging. We&#39;ve figured ou</p>
      </dd>
      <dd class="comment-timestamp"><a href="#831071325042142051" title="comment permalink">Friday, February 18, 2011 1:22:00 PM GMT</a>
	  <span class="item-control blog-admin pid-658342179"><a style="border:none;" href="http://www.blogger.com/delete-comment.g?blogID=25541020&postID=831071325042142051" title="Delete Comment" ><span class="delete-comment-icon">&nbsp;</span></a></span>
	  </dd>
      
    </dl>
		<p class="comment-timestamp">

    <a class="comment-link" href="https://www.blogger.com/comment.g?blogID=25541020&postID=2319446660716223785">Post a Comment</a>
    </p>
    	    
    


		<p class="comment-timestamp">
	<a href="http://augustss.blogspot.com/">&lt;&lt; Home</a>
    </p>
    </div>



  <!-- End #comments -->


</div></div>
<!-- End #main -->







<!-- Begin #sidebar -->
<div id="sidebar"><div id="sidebar2">
  
  
  <!-- Begin #profile-container -->

   <div id="profile-container"><h2 class="sidebar-title">About Me</h2>
<dl class="profile-datablock">
<dd class="profile-data"><strong>Name:</strong> <a rel="author" href="http://www.blogger.com/profile/07327620522294658036"> Lennart Augustsson </a></dd>
<dd class="profile-data"><strong>Location:</strong>  London, United Kingdom </dd></dl>

<p class="profile-link"><a rel="author" href="http://www.blogger.com/profile/07327620522294658036">View my complete profile</a></p></div>
   
  <!-- End #profile -->
    
        

  
  <h2 class="sidebar-title">Previous Posts</h2>
    <ul id="recently">
    
        <li><a href="http://augustss.blogspot.com/2008/12/ocaml-code-again-im-posting-slight.html">The OCaml code again
I&#39;m posting a slight variatio...</a></li>
     
        <li><a href="http://augustss.blogspot.com/2008/12/abstracting-on-suggested-solutions-i.html">Abstracting on, suggested solutions
I guess I shou...</a></li>
     
        <li><a href="http://augustss.blogspot.com/2008/12/abstraction-continues-i-got-several.html">The abstraction continues
I got several comments t...</a></li>
     
        <li><a href="http://augustss.blogspot.com/2008/12/somewhat-failed-adventure-in-haskell.html">A somewhat failed adventure in Haskell abstraction...</a></li>
     
        <li><a href="http://augustss.blogspot.com/2008/07/lost-and-found-if-i-write-108-in.html">Lost and found

If I write 10^8 in Haskell, how ma...</a></li>
     
        <li><a href="http://augustss.blogspot.com/2008/03/in-recent-blog-post-by-twan-van.html">Simple reflections of higher order

In a recent bl...</a></li>
     
        <li><a href="http://augustss.blogspot.com/2007/11/some-lambda-calculus-examples-syntax-in.html">Some lambda calculus examples

Syntax
In a previou...</a></li>
     
        <li><a href="http://augustss.blogspot.com/2007/11/benchmarking-ray-tracing-haskell-vs.html">Benchmarking ray tracing, Haskell vs. OCaml
On his...</a></li>
     
        <li><a href="http://augustss.blogspot.com/2007/10/simpler-easier-in-recent-paper-simply.html">Simpler, Easier!

In a recent paper, Simply Easy! ...</a></li>
     
        <li><a href="http://augustss.blogspot.com/2007/08/quicksort-in-haskell-quicksort-is.html">Quicksort in Haskell
Quicksort is a commonly used ...</a></li>
     
  </ul>
    

      <p id="powered-by"><a href="http://www.blogger.com"><img src="http://buttons.blogger.com/bloggerbutton1.gif" alt="Powered by Blogger" /></a></p>
  
  <!--
  <p>This is a paragraph of text that could go in the sidebar.</p>
  -->
  


</div></div>
<!-- End #sidebar -->


</div>
<!-- End #content -->



<!-- Begin #footer -->
<div id="footer"><hr />
  <p><!--This is an optional footer. If you want text here, place it inside these tags, and remove this comment. -->&nbsp;</p>

</div>
<!-- End #footer -->



<script type="text/javascript" src="http://www.blogger.com/static/v1/common/js/4153895687-csitail.js"></script>
<script type="text/javascript">BLOG_initCsi('classic_blogspot');</script></body>
</html>